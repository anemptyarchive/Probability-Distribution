---
title: "ウィシャート分布"
author: "@anemptyarchive\\thanks{\\url{https://www.anarchive-beta.com/}}"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: TRUE       # 目次
    toc_depth: 3    # 目次の見出しレベル
    toc_float: TRUE # 目次のスクロール追跡
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, error = FALSE, warning = FALSE # メッセージを非表示
)
```

----

【編集履歴】

- 2022/09/06：「分布の計算」を追加

----


# ウィシャート分布の計算

　ウィシャート分布(Wishart Distribution)の確率密度と統計量を計算します。ウィシャート分布については「分布の定義式」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(MCMCpack)
```

　この記事では、`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
\


## 確率密度の計算

　ウィシャート分布に従う確率密度を計算する方法をいくつか確認します。\
\


### パラメータの設定

　ウィシャート分布の次元数$D$とパラメータ$\nu, \mathbf{W}$、確率変数の実現値$\boldsymbol{\Lambda}$を設定します。

```{r}
# 次元数を指定
D <- 3

# 自由度を指定
nu <- D

# 逆スケール行列を指定
w_dd <- c(
  1.2, 0.6, -1.5, 
  0.6, 2.4, 0.4, 
  -1.5, 0.4, 3.6
) |> # 値を指定
  matrix(nrow = D, ncol = D) # マトリクスに変換

# 確率変数の値を指定
lambda_dd <- c(
  2, 0, -1, 
  0, 2.4, 0.4, 
  -1, 0.4, 4
) |> # 値を指定
  matrix(nrow = D, ncol = D) # マトリクスに変換
```

　自由度$\nu$と逆スケール行列$\mathbf{W}$を指定します。\
　$\nu > D - 1$、$\mathbf{W}$は$D \times D$の正定値行列を満たす必要があります。設定した値に従う確率密度を計算します。\
\


### スクラッチで計算

　定義式から確率密度を計算します。

```{r}
# 定義式により確率密度を計算
C_w1 <- 1 / sqrt(det(w_dd))^nu / sqrt(2)^(nu*D) / sqrt(pi)^(0.5*D*(D-1))
C_w2 <- 1 / prod(gamma(0.5 * (nu + 1 - 1:D)))
dens <- C_w1 * C_w2 * sqrt(det(lambda_dd))^(nu-D-1) * exp(-0.5 * sum(diag(solve(w_dd) %*% lambda_dd)))
dens
```

　ウィシャート分布は、次の式で定義されます。

$$
\begin{aligned}
C_{\mathcal{W}}
   &= \left(
          |\mathbf{W}|^{\frac{\nu}{2}}
          2^{\frac{\nu D}{2}}
          \pi^{\frac{D(D-1)}{4}}
          \prod_{d=1}^D
              \Gamma \Bigl(
                  \frac{\nu + 1 - d}{2}
              \Bigr)
      \right)^{-1}
\\
\mathcal{W}(\boldsymbol{\Lambda} | \nu, \mathbf{W})
   &= C_{\mathcal{W}}
      |\boldsymbol{\Lambda}|^{\frac{\nu-D-1}{2}}
      \exp \Bigl(
          - \frac{1}{2}
            \mathrm{Tr}(\mathbf{W}^{-1} \boldsymbol{\Lambda})
      \Bigr)
\end{aligned}
$$

　ここで、$C_{\mathcal{W}}$はウィシャート分布の正規化係数、$\pi$は円周率、$|\mathbf{A}|$は行列式、$\mathrm{Tr}(\mathbf{A})$はトレース、$\mathbf{A}^{-1}$は逆行列です。\
　円周率は`pi`、行列式は`det()`、トレースは`sum(diag())`、逆行列`solve()`、行列の積は`%*%`演算子で計算できます。\

　対数をとった定義式から計算します。

```{r}
# 対数をとった定義式により確率密度を計算
log_C_w1 <- -0.5 * (nu*log(det(w_dd)) + nu*D*log(2) + 0.5*D*(D-1)*log(pi))
log_C_w2 <- -sum(lgamma(0.5 * (nu + 1 - 1:D)))
log_dens <- log_C_w1 + log_C_w2 + 0.5 * ((nu - D - 1) * log(det(lambda_dd)) - sum(diag(solve(w_dd) %*% lambda_dd)))
dens <- exp(log_dens)
dens; log_dens
```

　対数をとった定義式を計算します。

$$
\begin{aligned}
\log C_{\mathcal{W}}
   &= - \frac{\nu}{2} \log |\mathbf{W}|
      - \frac{\nu D}{2} \log 2
      - \frac{D(D-1)}{4} \log \pi
      - \sum_{d=1}^D
          \log \Gamma \Bigl(
              \frac{\nu + 1 - d}{2}
          \Bigr)
\\
\log \mathcal{W}(\boldsymbol{\Lambda} | \nu, \mathbf{W})
   &= \log C_{\mathcal{W}}
      + \frac{\nu - D - 1}{2} \log |\boldsymbol{\Lambda}|
      - \frac{1}{2}
        \mathrm{Tr}(\mathbf{W}^{-1} \boldsymbol{\Lambda})
\end{aligned}
$$

　計算結果の指数をとると確率密度が得られます。

$$
\mathcal{W}(\boldsymbol{\Lambda} | \nu, \mathbf{W})
    = \exp \Bigr(
          \log \mathcal{W}(\boldsymbol{\Lambda} | \nu, \mathbf{W})
      \Bigr)
$$

　指数と対数の性質より$\exp(\log x) = x$です。\

　次は、関数を使って確率密度を計算します。\
\


### 関数で計算

　`MCMCpack`パッケージのウィシャート分布の確率密度関数`dwish()`で計算します。

```{r}
# ウィシャート分布の関数により確率密度を計算
dens <- MCMCpack::dwish(W = lambda_dd, v = nu, S = w_dd)
dens
```

　確率変数の引数`W`に`lambda_dd`、自由度の引数`v`に`nu`、逆スケール行列の引数`S`に`w_dd`を指定します。\
\


## 統計量の計算

　ウィシャート分布の統計量を計算します。\
\

　期待値を計算します。

```{r}
# 期待値を計算
E_lambda_dd <- nu * w_dd
E_lambda_dd
```

　ウィシャート分布の期待値は、次の式で計算できます。

$$
\mathbb{E}[\boldsymbol{\Lambda}]
    = \nu \mathbf{W}
$$

　1つの成分の分散を計算します。

```{r}
# 成分を指定
i <- 1
j <- 2

# 指定した成分の分散を計算
V_lambda_ij <- nu * (w_dd[i, j]^2 + w_dd[i, i] * w_dd[j, j])
V_lambda_ij
```

　ウィシャート分布の各成分の分散は、次の式で計算できます。

$$
\mathbb{V}[\lambda_{i,j}]
    = \nu (w_{i,j}^2 + w_{i,i} w_{j,j})
$$

　全ての成分の分散を計算します。

```{r}
# 対角成分を行方向に複製した行列を作成
w_ii <- w_dd |> 
  diag() |> # 対角成分を抽出
  rep(each = D) |> # 対角成分を複製
  matrix(nrow = D, ncol = D, byrow = TRUE) # マトリクスに変換

# 全ての成分の分散を計算
V_lambda_dd <- nu * (w_dd^2 + w_ii * t(w_ii))
V_lambda_dd; w_ii
```

　対角成分の積$w_{i,i} w_{j,j}$を計算するために、対角要素を各行(または列)の全ての要素に複製したマトリクス`w_ii`を作成して計算します。\

　最頻値を計算します。

```{r}
# 最頻値を計算:(ν > D+1)
mode_lambda_dd <- (nu - D - 1) * w_dd
mode_lambda_dd
```

　ウィシャート分布の最頻値は、次の式で計算できます。

$$
\mathrm{mode}[\boldsymbol{\Lambda}]
    = (\nu - D - 1) \mathbf{W}
    \quad
      (\nu > D + 1)
$$

\ 

　この記事では、ウィシャート分布の計算を確認しました。次は、乱数を生成します。\
\


# ウィシャート分布の乱数生成

　ウィシャート分布(Wishart Distribution)の乱数を生成します。ウィシャートス分布については「分布の定義式」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(mvnfast)
library(gganimate)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`は読み込む必要があります。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
　分布の変化をアニメーション(gif画像)で確認するのに`gganimate`パッケージを利用します。不要であれば省略してください。\
\


## サンプリング

　まずは、ウィシャート分布の乱数を生成します。\
\

　ウィシャートパラメータ$\nu, \mathbf{W}$とデータ数$N$を設定します。

```{r}
# 次元数を指定
D <- 4

# 自由度を指定
nu <- D + 2

# 逆スケール行列を指定
w_dd <- c(
  6,  0, 1, 4, 
  0,  2.4, -1, 0, 
  1, -1, 3.6, -1.7, 
  4, 0,  -1.7, 4.8
) |> # 値を指定
  matrix(nrow = D, ncol = D) # マトリクスに変換

# 逆スケール行列をランダムに設定
#w_dd <- rWishart(n = 1, df = D, Sigma = diag(D))[, , 1]

# データ数(サンプルサイズ)を指定
N <- 5000
```




```{r}
# ウィシャート分布に従う乱数を生成
lambda_ddn <- rWishart(n = N, df = nu, Sigma = w_dd)

# サンプルを格納
data_df <- tidyr::expand_grid(
  n = 1:N, # データ番号
  i = 1:D, # 行インデックス
  j = 1:D  # 列インデックス
) |> # 全ての組み合わせを作成
  #dplyr::filter(i <= j) |> # 重複を削除
  dplyr::group_by(n, i, j) |> # 値の抽出用にグループ化
  dplyr::mutate(
    lambda = lambda_ddn[i, j, n]
  ) |> # 次元ごとに値を抽出
  dplyr::ungroup() # グループ化を解除
data_df
```



```{r}
# 統計量を計算
stat_df <- tidyr::expand_grid(
  i = 1:D, # 行インデックス
  j = 1:D  # 列インデックス
) |> # 全ての組み合わせを作成
  #dplyr::filter(i <= j) |> # 重複を削除
  dplyr::group_by(i, j) |> # 値の抽出用にグループ化
  dplyr::mutate(
    mean = nu * w_dd[i, j], # 期待値
    mode = dplyr::if_else(
      condition = nu > D + 1, 
      true = (nu - D - 1) * w_dd[i, j], 
      false = as.numeric(NA)
    ) # 最頻値
  ) |> # 次元ごとに統計量を計算
  dplyr::ungroup() |> # グループ化を解除
  tidyr::pivot_longer(
    cols = c(mean, mode), 
    names_to = "type", 
    values_to = "statistic"
  )
stat_df
```


```{r}
# 逆スケール行列ラベルを作成
label_df <- tidyr::expand_grid(
  i = 1:D, # 行インデックス
  j = 1:D  # 列インデックス
) |> # 全ての組み合わせを作成
  #dplyr::filter(i <= j) |> # 重複を削除
  dplyr::group_by(i, j) |> # 値の抽出用にグループ化
  dplyr::mutate(
    label = paste0("w[", i, j, "]==", round(w_dd[i, j], 2))
  ) |> # 次元ごとにラベルを作成
  dplyr::ungroup() # グループ化を解除
label_df
```



```{r}
# 凡例用の設定を作成:(数式表示用)
color_vec <- c(mean = "blue", mode = "chocolate")
label_vec <- c(mean = expression(E(lambda[ij])), mode = expression(mode(lambda[ij])))
```


```{r, fig.width=12, fig.height=9}
# サンプルのヒストグラムを作成
ggplot() + 
  geom_histogram(data = data_df, mapping = aes(x = lambda, y = ..count..), 
                 bins = 50, fill = "#00A968") + # サンプル
  geom_vline(data = stat_df, mapping = aes(xintercept = statistic, color = type), 
             linetype = "dashed") + # 統計量
  geom_label(data = label_df, mapping = aes(x = max(lambda_ddn), y = N*0.01, label = label), 
             parse = TRUE, vjust = "inward", hjust = "inward", alpha = 0.5) + # パラメータラベル
  facet_grid(i ~ j, labeller = label_bquote(rows = i==.(i), cols = j==.(j))) + # グラフの分割
  scale_color_manual(values = color_vec, labels = label_vec, name = "statistic") + # 線の色:(数式表示用)
  theme(legend.text.align = 0) + # 図の体裁:凡例
  labs(title = "Wishart Distribution", 
       subtitle = parse(text = paste0("list(D==", D, ", nu==", nu, ", W==(list(w[11], ..., w[DD])), N==", N, ")")), 
       x = expression(lambda[ij]), y = "frequency")
```


