---
title: "多次元ガウス分布"
author: "@anemptyarchive\\thanks{\\url{https://www.anarchive-beta.com/}}"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: TRUE       # 目次
    toc_depth: 3    # 目次の見出しレベル
    toc_float: TRUE # 目次のスクロール追跡
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, error = FALSE, warning = FALSE # メッセージを非表示
)
```

----

【編集履歴】

- 2022/08/27：「相関行列との関係」を追加
- 2022/08/29：「マハラノビス距離との関係」を追加
- 2022/09/03：「固有値・固有ベクトルとの関係」を追加
- 2022/09/04：「固有ベクトルによる分布の回転」を追加

----


# 分散共分散行列と相関行列の変換

　分散共分散行列(Variance–Covariance Matrix)と相関行列(Correlation Matrix)の関係を計算して確認します。計算式については「分散共分散行列と相関行列の関係の導出」を参照してください。\
\

　この記事では、`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。  
\


## 分散共分散行列の設定

　まずは、分散共分散行列を設定します。\
\

　分散共分散行列$\boldsymbol{\Sigma}$を作成します。

```{r}
# 次元数を指定
D <- 3

# 分散共分散行列を指定
sigma_dd <- c(
  4, 1.8, -0.1, 
  1.8, 9, 2.4, 
  -0.1, 2.4, 1
) |> # 値を指定
  matrix(nrow = D, ncol = D, byrow = TRUE) # マトリクスに変換
sigma_dd
```

　$D \times D$の正定値行列を指定します。

$$
\boldsymbol{\Sigma}
    = \begin{pmatrix}
          \sigma_1^2 & \sigma_{1,2} & \cdots & \sigma_{1,D} \\
          \sigma_{2,1} & \sigma_2^2 & \cdots & \sigma_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \sigma_{D,1} & \sigma_{D,2} & \cdots & \sigma_D^2
      \end{pmatrix}
$$

　$D$次元ベクトルの変数を$\mathbf{x} = (x_1, x_2, \cdots, x_D)^{\top}$とすると、$\sigma_d$は$x_d$の標準偏差、$\sigma_d^2 = \sigma_{d,d}$は$x_d$の分散、$\sigma_{i,j} = \sigma_{j,i}$は$x_i, x_j$の共分散です。
　$\sigma_d^2$は正の実数、$\sigma_{i,j}\ (i \neq j)$は実数を満たす必要があります。設定した値に従う相関係数などを計算します。\
\


## 標準偏差と相関係数の計算

　次に、分散と共分散を用いて標準偏差と相関係数を計算します。\
\

　注目する成分番号(インデックス)$i, j$を指定します。

```{r}
# 次元を指定
i <- 1
j <- 2
```

　行番号を`i`、列番号を`j`とします。\

　分散$\sigma_i^2, \sigma_j^2$を抽出します。

```{r}
# 分散を抽出
sigma2_i <- sigma_dd[i, i]
sigma2_j <- sigma_dd[j, j]
sigma2_i; sigma2_j
```

　インデックスを指定して`sigma_dd`の対角成分(対角要素)を抽出します。\

　ちなみに、全ての対角成分は`diag()`で抽出できます。

```{r}
# 全ての分散を抽出
diag(sigma_dd)
```

　`diag()`にマトリクスを渡すと対角要素を返します。マトリクスの形状に関わらず抽出できます。\

　共分散$\sigma_{i,j}, \sigma_{j,i}$を抽出します。\

```{r}
# 共分散を抽出
sigma_ij <- sigma_dd[i, j]
sigma_ji <- sigma_dd[j, i]
sigma_ij; sigma_ji
```

　インデックスを指定して`sigma_dd`の要素を抽出します。$\sigma_{i,j} = \sigma_{j,i}$なのを確認できます。\

　標準偏差$\sigma_i, \sigma_j$を計算します。

```{r}
# 標準偏差を計算
sigma_i <- sqrt(sigma2_i)
sigma_j <- sqrt(sigma2_j)
sigma_i; sigma_j
```

　分散の平方根をとります。

$$
\sigma_d
    = \sqrt{\sigma_d^2}
$$

　相関係数$\rho_{i,i} \rho_{i,j}, \rho_{j,i}, \rho_{j,j}$を計算します。

```{r}
# 相関係数を計算
rho_ii <- sigma2_i / sigma_i / sigma_i
rho_ij <- sigma_ij / sigma_i / sigma_j
rho_ji <- sigma_ji / sigma_j / sigma_i
rho_jj <- sigma2_j / sigma_j / sigma_j
rho_ii; rho_ij; rho_ji; rho_jj
```

　分散を対応する標準偏差で割ります。

$$
\rho_{i,j}
    = \frac{\sigma_{i,j}}{\sigma_i \sigma_j}
$$

　$\rho_{i,j} = \rho_{j,i}$、$\rho_{d,d} = \frac{\sigma_d^2}{\sigma_d \sigma_d} = 1$になるのを確認できます。\

　$D \times D$の相関係数を並べた行列を相関行列と言います。

$$
\mathbf{P}
    = \begin{pmatrix}
          \rho_{1,1} & \rho_{1,2} & \cdots & \rho_{1,D} \\
          \rho_{2,1} & \rho_{2,2} & \cdots & \rho_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \rho_{D,1} & \rho_{D,2} & \cdots & \rho_{D,D}
      \end{pmatrix}
    = \begin{pmatrix}
          1 & \rho_{1,2} & \cdots & \rho_{1,D} \\
          \rho_{2,1} & 1 & \cdots & \rho_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \rho_{D,1} & \rho_{D,2} & \cdots & 1
      \end{pmatrix}
$$

　対角成分が1の対称行列です。\
\


## 分散共分散行列と相関行列の計算

　最後に、分散共分散行列と相関行列を計算します。\
\

　計算に利用する2つの対角行列、標準偏差$\sigma_d$を対角成分とする行列$\mathbf{S}$と、標準偏差の逆数$\frac{1}{\sigma_d}$を対角成分とする行列$\mathbf{S}^{-1}$を作成します。

$$
\mathbf{S}
    = \begin{pmatrix}
          \sigma_1 & 0 & \cdots & 0 \\
          0 & \sigma_2 & \cdots & 0 \\
          \vdots & \vdots & \ddots & \vdots \\
          0 & 0 & \cdots & \sigma_D
      \end{pmatrix}
,\ 
\mathbf{S}^{-1}
    = \begin{pmatrix}
          \frac{1}{\sigma_1} & 0 & \cdots & 0 \\
          0 & \frac{1}{\sigma_2} & \cdots & 0 \\
          \vdots & \vdots & \ddots & \vdots \\
          0 & 0 & \cdots & \frac{1}{\sigma_D}
      \end{pmatrix}
$$

　対角行列の逆行列は、対角成分の逆数を対角成分とする対角行列になるので、$\sigma_d$の行列と$\frac{1}{\sigma_d}$の行列は逆行列の関係です。\

　分散共分散行列$\boldsymbol{\Sigma}$を使って、$\sigma_d$の行列$\mathbf{S}$を作成します。

```{r}
# 標準偏差が対角成分の行列を作成
s_dd <- sigma_dd |> 
  diag() |> # 対角成分(分散)を抽出
  (\(.){sqrt(.)})() |> # 標準偏差を計算
  diag() # 対角行列を作成
s_dd
```

　`sigma_dd`の対角要素(分散)を`diag()`で抽出します。D個の分散からそれぞれ標準偏差を計算して、`diag()`で対角行列を作成します。`diag()`にベクトルを渡すと対角行列を返します。\
　標準偏差の計算処理では、無名関数`function()`の省略記法`\()`を使って、`(\(引数){引数を使った具体的な処理})()`としています。直前のパイプ演算子を`%>%`にすると、行全体`(\(引数){処理})()`を`{}`の中の`処理`(この例だと`sqrt(.)`)に置き換えられます(置き換えられるように引数名を`.`にしています)。\

　同様に、$\frac{1}{\sigma_d}$の行列$\mathbf{S}^{-1}$を作成します。

```{r}
# 標準偏差の逆数が対角成分の行列を作成
s_inv_dd <- sigma_dd |> 
  diag() |> # 対角成分(分散)を抽出
  (\(.){1 / sqrt(.)})() |> # 標準偏差の逆数を計算
  diag() # 対角行列を作成
s_inv_dd
```

　こちらは、標準偏差の逆数を計算して、対角行列を作成します。\

　$\mathbf{S}$がある場合は、逆行列を計算して$\mathbf{S}^{-1}$を作成できます。

```{r}
# 標準偏差の逆数が対角成分の行列を計算
s_inv_dd <- solve(s_dd)
s_inv_dd
```

　`s_dd`の逆行列を`solve()`で計算します。\

　逆に、$\mathbf{S}^{-1}$から$\mathbf{S}$も計算できます。

```{r}
# 標準偏差が対角成分の行列を計算
s_dd <- solve(s_inv_dd)
s_dd
```

　逆行列の逆行列を計算すると元の行列になります。\

　利用する行列を用意できたので、分散共分散行列から相関係数を計算します。

```{r}
# 相関行列を計算
rho_dd <- s_inv_dd %*% sigma_dd %*% s_inv_dd
rho_dd
```

　分散共分散行列$\boldsymbol{\Sigma}$の左右から$\mathbf{S}$の逆行列を掛けると、相関行列$\mathbf{P}$が求まります。

$$
\mathbf{P}
    = \mathbf{S}^{-1} \boldsymbol{\Sigma} \mathbf{S}^{-1}
$$

　`rho_dd[i, j]`が`rho_ij`の値になっているのを確認できます。\

　相関行列から分散共分散行列を計算します。

```{r}
# 分散共分散行列を計算
sigma_dd <- s_dd %*% rho_dd %*% s_dd
sigma_dd
```

　相関行列$\mathbf{P}$の左右から$\mathbf{S}$を掛けると、分散共分散行列$\boldsymbol{\Sigma}$が求まります。

$$
\boldsymbol{\Sigma}
    = \mathbf{S} \mathbf{P} \mathbf{S}
$$

　元の値になるのを確認できます。\
\

　この記事では、分散共分散行列と相関行列の関係を確認しました。次は、固有値・固有ベクトルとの関係を確認します。\
\


# 分散共分散行列とユークリッド距離・マハラノビス距離の関係の可視化

　分散共分散行列(Variance–Covariance Matrix)とユークリッド距離(Euclidean Distance)・マハラノビス距離(Mahalanobis Dostance)の関係を2次元ガウス分布を用いて可視化します。分散共分散行列と距離の関係については「分散共分散行列とユークリッド距離・マハラノビス距離の関係の導出」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(mvnfast)
library(ggrepel)
```

```{r, echo=FALSE}
### 資料作成用:(チェック用)

# チェック用
library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`は読み込む必要があります。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
\


## 距離の計算




## サンプルの距離の可視化

　2次元ガウス分布の乱数を生成して、サンプルごとのユークリッド距離とマハラノビス距離を可視化します。2次元ガウス分布のグラフ作成については「2次元ガウス分布の作図」、乱数生成については「多次元ガウス分布の乱数生成」を参照してください。\
\

　ガウス分布のパラメータ$\boldsymbol{\mu}, \boldsymbol{\Sigma}$を設定します。この例では、2次元のグラフで可視化するため、次元数を$D = 2$とします。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散共分散行列を指定
sigma_dd <- matrix(c(1, 0.6, 0.6, 1.5), nrow = 2, ncol = 2)
```

　平均ベクトル$\boldsymbol{\mu} = (\mu_1, \mu_2)$、分散共分散行列$\boldsymbol{\Sigma} = (\sigma_1^2, \sigma_{2,1}, \sigma_{1,2}, \sigma_2^2)$を指定します。\
　平均$\mu_d$は実数、分散$\sigma_d^2$は非負の実数、共分散$\sigma_{1,2}$は実数、また$\boldsymbol{\Sigma}$は正定値行列を満たす必要があります。\

　設定したパラメータに応じて、ガウス分布の確率変数がとり得る値$\mathbf{x}$を作成します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma_dd[1, 1]) * 3, 
  to = mu_d[1] + sqrt(sigma_dd[1, 1]) * 3, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma_dd[2, 2]) * 3, 
  to = mu_d[2] + sqrt(sigma_dd[2, 2]) * 3, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, # x軸の値
  x_2 = x_2_vals # y軸の値
) |> # 格子点を作成
  as.matrix() # マトリクスに変換
head(x_mat)
```

　$x_1$(x軸)の値を`x_1_vals`、$x_2$(y軸)の値を`x_2_vals`とします。この例では、それぞれ平均を中心に標準偏差の3倍を範囲とします。\
　`x_1_vals`と`x_2_vals`の要素の全ての組み合わせ(格子状の点)を`expand_grid()`で作成します。データフレームが出力されるので、`as.matrix()`でマトリクスに変換して`x_mat`とします。`x_mat`の各行が点$\mathbf{x} = (x_1, x_2)$に対応します。\

　$\mathbf{x}$の点ごとの確率密度を計算します。

```{r}
# 多次元ガウス分布を計算
dens_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = x_mat, mu = mu_d, sigma = sigma_dd) # 確率密度
)
dens_df
```

　多次元ガウス分布の確率密度は、`mvnfast`パッケージの`dmvn()`で計算できます。確率変数の引数`X`に`x_mat`、平均の引数`mu`に`mu_d`、共分散の引数`sigma`に`sigma_dd`を指定します。\

　$\mathbf{x}$の点ごとのユークリッド距離とマハラノビス距離を計算します。

```{r}
# 点ごとに距離を計算
dist_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  euclidean = apply((t(x_mat) - mu_d)^2, 2, sum) |> 
    sqrt(), # ユークリッド距離
  mahalanobis = t(t(x_mat)-mu_d) %*% solve(sigma_dd) %*% (t(x_mat)-mu_d) |> 
    diag() |> 
    sqrt() # マハラノビス距離
)
dist_df
```

　ユークリッド距離とマハラノビス距離は、それぞれ次の式で定義されます。

$$
\begin{aligned}
\Delta_{\mathrm{euclid}}
   &= \sqrt{
          \sum_{d=1}^D
              (x_d - \mu_d)^2
      }
\\
\Delta_{\mathrm{mahal}}
   &= \sqrt{
          (\mathbf{x} - \boldsymbol{\mu})^{\top}
          \boldsymbol{\Sigma}^{-1}
          (\mathbf{x} - \boldsymbol{\mu})
      }
\end{aligned}
$$

　転置は`t()`、逆行列の計算は`solve()`、行列の積の計算は`%*%`演算子で行えます。\
　ただし、複数個の$\mathbf{x}$を同時に処理するために、適宜転置して計算する必要があります。また、二次形式(平方根の中)の計算において全ての点の組み合わせで処理されます。そのため、同じ点による計算結果(対角要素)を`daig()`で取り出します。\
\

　作図用の$\mathbf{x}$に関して処理できました。次は、サンプル$\mathbf{x}_n$に関して処理します。\

　ガウス分布に従う乱数を生成します。

```{r}
# データ数(サンプルサイズ)を指定
N <- 10

# 多次元ガウス分布に従う乱数を生成
x_nd <- mvnfast::rmvn(n = N, mu = mu_d, sigma = sigma_dd)
head(x_nd)
```

　多次元ガウス分布の乱数は、`mvnfast`パッケージの`rmvn()`で生成できます。データ数の引数`n`に`N`、平均の引数`mu`に`mu_d`、共分散の引数`sigma`に`sigma_dd`を指定します。\
　生成した値をN個のサンプル`x_nd`とします。`x_nd`の各行が$\mathbf{x}_n = (x_{n,1}, x_{n,2})$に対応します。\

　サンプル$\mathbf{x}_n$ごとにユークリッド距離とマハラノビス距離を計算します。

```{r}
# サンプルごとに距離を計算
data_df <- tibble::tibble(
  n = factor(1:N), # データ番号
  x_1 = x_nd[, 1], # x軸の値
  x_2 = x_nd[, 2], # y軸の値
  euclidean = apply((t(x_nd) - mu_d)^2, 2, sum) |> 
    sqrt(), # ユークリッド距離
  mahalanobis = t(t(x_nd)-mu_d) %*% solve(sigma_dd) %*% (t(x_nd)-mu_d) |> 
    diag() |> 
    sqrt(), # マハラノビス距離
  coord_label = paste0("x=(", round(x_1, 1), ", ", round(x_2, 1), ")"), # 座標ラベル
  dist_label = paste0("ED=", round(euclidean, 2), "\nMD=", round(mahalanobis, 2)) # 距離ラベル
)
data_df
```

　先ほどと同様に計算します。こちらは、色分け用の因子型のデータ番号列と、グラフに載せる情報として座標と距離のラベル列を作成します。\
\

　作図用のデータフレームを作成できました。次は、作図処理を行います。\

　生成分布の確率密度の等高線と、ユークリッド距離とマハラノビス距離の等高線に、サンプルを重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8}
# 距離の等高線のプロット位置を指定
dist_vals <- seq(from = 1, to = 5, by = 1)

# パラメータラベルを作成:(数式表示用)
math_text <- paste0(
  "list(", 
  "mu==group('(', list(", paste0(mu_d, collapse = ", "), "), ')')", 
  ", Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)

# サンプルごとのユークリッド距離とマハラノビス距離の可視化
ggplot() + 
  geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = euclidean, linetype = "ed"), 
               breaks = dist_vals, color = "pink", size = 1) + # ユークリッド距離
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = mahalanobis, linetype = "md"), 
               breaks = dist_vals, color = "skyblue", size = 1) + # マハラノビス距離
  geom_segment(data = data_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = x_1, yend = x_2, color = n), 
               arrow = arrow(length = unit(5, "pt"), type = "closed"), show.legend = FALSE) + # 期待値とサンプルの線分
  geom_point(data = data_df, mapping = aes(x = x_1, y = x_2, color = n), 
             alpha = 0.8, size = 5, show.legend = FALSE) + # サンプル
  ggrepel::geom_label_repel(data = data_df, mapping = aes(x = x_1, y = x_2, color = n, label = paste0(coord_label, "\n", dist_label)), 
                            alpha = 0.8, size = 2.5, label.padding = unit(3, "pt"), 
                            box.padding = unit(10, "pt"), point.padding = unit(10, "pt"), 
                            min.segment.length = 0, max.overlaps = Inf, show.legend = FALSE) + # サンプルラベル
  coord_fixed(ratio = 1) + # アスペクト比
  scale_linetype_manual(breaks = c("ed", "md"), values = c("solid", "solid"), 
                        labels = c("euclidean", "mahalanobis"), name = "distance") + # (凡例表示用の黒魔術)
  guides(linetype = guide_legend(override.aes = list(color = c("pink", "skyblue")))) + # (凡例表示用の黒魔術)
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = math_text), # (数式表示用)
       color = "x", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

　確率密度の塗りつぶし等高線図を`geom_contour_filled()`で描画します。\
　ユークリッド距離とマハラノビス距離の等高線図をそれぞれ`geom_contour()`で描画します。線を引くz軸の値の引数`breaks`に値を指定します。この例では、1から5の整数とします。\
　期待値(距離が0の点)と各サンプルを結ぶ線分を`geom_segment()`で描画します。\
　サンプルの散布図を`geom_point()`で描画します。\
　サンプルごとの距離を`ggrepel`パッケージの`geom_label_repel()`でラベルとして表示します。\
　ユークリッド距離の等高線は、アスペクト比が1のとき円になります。グラフのアスペクト比は`coord_fixed()`の`ratio`引数で指定できます。\
\

　続いて、ユークリッド距離とマハラノビス距離が等しい等高線を1本だけ引いて比較します。\

　線を引く距離を指定して、それぞれの距離の内外のサンプルを判別します。

```{r}
# 距離を指定
dist <- 1.5

# 指定した範囲の内外を判定
data_df2 <- data_df |> 
  dplyr::mutate(
    color_flag = dplyr::case_when(
      euclidean <= dist & mahalanobis <= dist ~ "both", 
      euclidean <= dist ~ "euclid", 
      mahalanobis <= dist ~ "mahal", 
      TRUE ~ "none"
    ) # 色分け用フラグ
  )
data_df2
```

　`case_when()`で場合分けして色分け用のラベルを作成します(距離の内外で色分けする必要はありません)。\

　確率密度と距離の等高線にサンプルを重ねなグラフを作成します。

```{r, fig.width=8, fig.height=8}
# ユークリッド距離とマハラノビス距離の比較
ggplot() + 
  geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = euclidean, linetype = "ed"), 
               breaks = dist, color = "pink", size = 1) + # ユークリッド距離
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = mahalanobis, linetype = "md"), 
               breaks = dist, color = "skyblue", size = 1) + # マハラノビス距離
  geom_point(data = data_df2, mapping = aes(x = x_1, y = x_2, color = color_flag), 
             alpha = 0.8, size = 5, show.legend = FALSE) + # サンプル
  geom_label(mapping = aes(x = min(x_1_vals), y = max(x_2_vals), label = paste0("dist:", dist)), 
             hjust = 0) + # 距離ラベル
  coord_fixed(ratio = 1) + # アスペクト比
  scale_color_manual(breaks = c("both", "euclid", "mahal", "none"), 
                     values = c("#00A968", "pink", "skyblue", "gray")) + # サンプルの色
  scale_linetype_manual(breaks = c("ed", "md"), values = c("solid", "solid"), 
                        labels = c("euclidean", "mahalanobis"), name = "distance") + # (凡例表示用の黒魔術)
  guides(linetype = guide_legend(override.aes = list(color = c("pink", "skyblue")))) + # (凡例表示用の黒魔術)
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = math_text), 
       color = "x", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

　サンプルの色分けを設定する場合は、`scale_color_manual()`の`breaks`引数にラベルの文字列、`values`引数に色を指定します。\
\

・分散共分散行列が単位行列の場合

```{r, echo=FALSE, fig.width=8, fig.height=8}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散共分散行列を指定
sigma_dd <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)

# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma_dd[1, 1]) * 3, 
  to = mu_d[1] + sqrt(sigma_dd[1, 1]) * 3, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma_dd[2, 2]) * 3, 
  to = mu_d[2] + sqrt(sigma_dd[2, 2]) * 3, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, # x軸の値
  x_2 = x_2_vals # y軸の値
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# 多次元ガウス分布を計算
dens_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = x_mat, mu = mu_d, sigma = sigma_dd) # 確率密度
)

# 点ごとに距離を計算
dist_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  euclidean = apply((t(x_mat) - mu_d)^2, 2, sum) |> 
    sqrt(), # ユークリッド距離
  mahalanobis = t(t(x_mat)-mu_d) %*% solve(sigma_dd) %*% (t(x_mat)-mu_d) |> 
    diag() |> 
    sqrt() # マハラノビス距離
)

# データ数(サンプルサイズ)を指定
N <- 10

# 多次元ガウス分布に従う乱数を生成
x_nd <- mvnfast::rmvn(n = N, mu = mu_d, sigma = sigma_dd)

# サンプルごとに距離を計算
data_df <- tibble::tibble(
  n = factor(1:N), # データ番号
  x_1 = x_nd[, 1], # x軸の値
  x_2 = x_nd[, 2], # y軸の値
  euclidean = apply((t(x_nd) - mu_d)^2, 2, sum) |> 
    sqrt(), # ユークリッド距離
  mahalanobis = t(t(x_nd)-mu_d) %*% solve(sigma_dd) %*% (t(x_nd)-mu_d) |> 
    diag() |> 
    sqrt(), # マハラノビス距離
  coord_label = paste0("x=(", round(x_1, 1), ", ", round(x_2, 1), ")"), # 座標ラベル
  dist_label = paste0("ED=", round(euclidean, 2), "\nMD=", round(mahalanobis, 2)) # 距離ラベル
)

# 距離の等高線のプロット位置を指定
dist_vals <- seq(from = 1, to = 10, by = 1)

# パラメータラベルを作成:(数式表示用)
math_text <- paste0(
  "list(", 
  "mu==group('(', list(", paste0(mu_d, collapse = ", "), "), ')')", 
  ", Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)

# サンプルごとのユークリッド距離とマハラノビス距離の可視化
ggplot() + 
  geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = euclidean, linetype = "ed"), 
               breaks = dist_vals, color = "pink", size = 1) + # ユークリッド距離
  geom_contour(data = dist_df, mapping = aes(x = x_1, y = x_2, z = mahalanobis, linetype = "md"), 
               breaks = dist_vals, color = "skyblue", size = 1) + # マハラノビス距離
  geom_segment(data = data_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = x_1, yend = x_2, color = n), 
               arrow = arrow(length = unit(5, "pt"), type = "closed"), show.legend = FALSE) + # 期待値とサンプルの線分
  geom_point(data = data_df, mapping = aes(x = x_1, y = x_2, color = n), 
             alpha = 0.8, size = 5, show.legend = FALSE) + # サンプル
  ggrepel::geom_label_repel(data = data_df, mapping = aes(x = x_1, y = x_2, color = n, label = paste0(coord_label, "\n", dist_label)), 
                            alpha = 0.8, size = 2.5, label.padding = unit(3, "pt"), 
                            box.padding = unit(10, "pt"), point.padding = unit(10, "pt"), 
                            min.segment.length = 0, max.overlaps = Inf, show.legend = FALSE) + # サンプルラベル
  coord_fixed(ratio = 1) + # アスペクト比
  scale_linetype_manual(breaks = c("ed", "md"), values = c("solid", "solid"), 
                        labels = c("euclidean", "mahalanobis"), name = "distance") + # (凡例表示用の黒魔術)
  guides(linetype = guide_legend(override.aes = list(color = c("pink", "skyblue")))) + # (凡例表示用の黒魔術)
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = math_text), # (数式表示用)
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

　確率密度(の等高線)とマハラノビス距離(の等高線)が対応しているのが分かります。\
　分散共分散行列が単位行列の場合、ユークリッド距離とマハラノビス距離が一致します。\
\


## パラメータと距離の関係をアニメーションで可視化

　パラメータの値を少しずつ変化させて、ユークリッド距離とマハラノビス距離の等高線の変化をアニメーションで確認します。\
\


### 分散(1軸)の影響

　まずは、x軸方向の分散$\sigma_1^2$の値を変化させ、$\sigma_{1,2}, \sigma_{2,1}, \sigma_2^2$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(0, 0)

# x軸の分散として利用する値を指定
sigma2_1_vals <- seq(from = 0.5, to = 5, by = 0.1) |> 
  round(2)

# y軸の分散を指定
sigma2_2 <- 2

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を確認
length(sigma2_1_vals)
```

　値の間隔が一定になるように$\sigma_1^2$の値を`sigma2_1_vals`として作成します。パラメータごとにフレームを切り替えるので、`sigma2_1_vals`の要素数がアニメーションのフレーム数になります。\
　また、共分散$\sigma_{1,2} = \sigma_{2,1}$を`sigma2_2`、y軸方向の分散$\sigma_2^2$を`sigma2_2`として値を指定します。\

　設定したパラメータに応じて確率変数の値$\mathbf{x}$を作成して、パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(max(sigma2_1_vals)) * 2, 
  to = mu_d[1] + sqrt(max(sigma2_1_vals)) * 2, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_1 = sigma2_1_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_1) |> # 確率密度の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = x_mat, 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　パラメータ`sigma2_1_vals`と確率変数`x_1_vals, x_2_vals`の要素の全ての組み合わせを`expand_grid()`を作成します。これにより、パラメータごとに`x_mat`を複製できます。\
　パラメータ列`sigma2_1`でグループ化することで、`x_mat`ごとに確率密度を計算できます。\
　パラメータごとにフレーム切替用のラベルを作成します。文字列型だと文字列の基準で順序が決まるので、因子型にしてパラメータに応じたレベル(順序)を設定します。\

　同様に、パラメータごとに描画範囲全体の距離を計算します。

```{r}
# パラメータごとに距離を計算
anime_dist_df <- tidyr::expand_grid(
  sigma2_1 = sigma2_1_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_1) |> # 距離の計算用にグループ化
  dplyr::mutate(
    euclidean = apply((t(x_mat) - mu_d)^2, 2, sum) |> 
      sqrt(), # ユークリッド距離
    mahalanobis = t(t(x_mat)-mu_d) %*% solve(matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2)) %*% (t(x_mat)-mu_d) |> 
      diag() |> 
      sqrt(), # マハラノビス距離
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  tidyr::pivot_longer(
    cols = c(euclidean, mahalanobis), 
    names_to = "type", 
    values_to = "distance"
  ) # 距離の列をまとめる
anime_dist_df
```

　「サンプルの距離の可視化」と同様に計算した2つの距離の列を`pivot_longer()`でまとめます。\

　等高線のアニメーション(gif画像)を作成します。

```{r}
# 距離の等高線のプロット位置を指定
dist_vals <- seq(from = 0, to = 10, by = 1)

# ユークリッド距離とマハラノビス距離のアニメーションを作図
anime_dist_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = anime_dist_df, mapping = aes(x = x_1, y = x_2, z = distance, color = type), 
               breaks = dist_vals, size = 1) + # 距離
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  scale_color_manual(breaks = c("euclidean", "mahalanobis"), values = c("pink", "skyblue"), name = "distance") + # 線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dist_graph, nframes = length(sigma2_1_vals), fps = 10, width = 800, height = 800)
```

　`transition_manual()`にフレームの順序を表す列を指定します。この例では、因子型のラベルのレベルの順に描画されます。\
　`animate()`のフレーム数の引数`nframes`にパラメータ数、フレームレートの引数`fps`に1秒当たりのフレーム数を指定します。`fps`引数の値が大きいほどフレームが早く切り替わります。ただし、値が大きいと意図通りに動作しません。\

　$\sigma_1^2$が大きくなるほど、x軸方向のマハラノビス距離が変化しています。ユークリッド距離は変化しません。これは計算式に$\boldsymbol{\Sigma}$を含まないためです。\
\


### 分散(2軸)の影響

　次は、y軸方向の分散$\sigma_2^2$の値を変化させ、$\sigma_1^2, \sigma_{1,2}, \sigma_{2,1}$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(0, 0)

# x軸の分散を指定
sigma2_1 <- 2

# y軸の分散として利用する値を指定
sigma2_2_vals <- seq(from = 0.5, to = 5, by = 0.1) |> 
  round(2)

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を確認
length(sigma2_2_vals)
```

　値の間隔が一定になるように$\sigma_2^2$の値を`sigma2_2_vals`として作成します。\
　また、x軸方向の分散$\sigma_1^2$を`sigma2_1`として値を指定します。\

　確率変数の値を作成して、パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(max(sigma2_2_vals)) * 2, 
  to = mu_d[2] + sqrt(max(sigma2_2_vals)) * 2, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_2 = sigma2_2_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_2) |> # 確率密度の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = x_mat, 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「分散(1軸)の影響」と同様に処理します。\

　パラメータごとに描画範囲全体の距離を計算します。

```{r}
# パラメータごとに距離を計算
anime_dist_df <- tidyr::expand_grid(
  sigma2_2 = sigma2_2_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_2) |> # 距離の計算用にグループ化
  dplyr::mutate(
    euclidean = apply((t(x_mat) - mu_d)^2, 2, sum) |> 
      sqrt(), # ユークリッド距離
    mahalanobis = t(t(x_mat)-mu_d) %*% solve(matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)) %*% (t(x_mat)-mu_d) |> 
      diag() |> 
      sqrt(), # マハラノビス距離
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  tidyr::pivot_longer(
    cols = c(euclidean, mahalanobis), 
    names_to = "type", 
    values_to = "distance"
  ) # 距離の列をまとめる
anime_dist_df
```

　「分散(1軸)の影響」と同様に処理します。\

　「分散(1軸)の影響」のコードで作図できます。フレーム数は`sigma2_2_vals`の要素数です。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# ユークリッド距離とマハラノビス距離のアニメーションを作図
anime_dist_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = anime_dist_df, mapping = aes(x = x_1, y = x_2, z = distance, color = type), 
               breaks = dist_vals, size = 1) + # 距離
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  scale_color_manual(breaks = c("euclidean", "mahalanobis"), values = c("pink", "skyblue"), name = "distance") + # 線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

```{r}
# gif画像を作成
gganimate::animate(anime_dist_graph, nframes = length(sigma2_2_vals), fps = 10, width = 800, height = 800)
```

　$\sigma_2^2$が大きくなるほど、y軸方向のマハラノビス距離が変化しています。\
\


### 共分散の影響

　最後に、共分散$\sigma_{1,2} = \sigma_{2,1}$の値を変化させ、$\sigma_1^2, \sigma_2^2$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(0, 0)

# 分散を指定
sigma2_1 <- 3
sigma2_2 <- 4.5

# 共分散を指定として利用する値を指定
sigma_12_vals <- seq(from = -2, to = 2, by = 0.1) |> 
  round(2)

# フレーム数を確認
length(sigma_12_vals)
```

　値の間隔が一定になるように$\sigma_{1,2}$の値を`sigma_12_vals`として作成します。\

　確率変数の値を作成して、パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma_12 = sigma_12_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma_12) |> # 確率密度の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = x_mat, 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12_vals, ", ", sigma_12_vals, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「分散(1軸)の影響」と同様に処理します。\

　パラメータごとに描画範囲全体の距離を計算します。

```{r}
# パラメータごとに距離を計算
anime_dist_df <- tidyr::expand_grid(
  sigma_12 = sigma_12_vals, 
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma_12) |> # 距離の計算用にグループ化
  dplyr::mutate(
    euclidean = apply((t(x_mat) - mu_d)^2, 2, sum) |> 
      sqrt(), # ユークリッド距離
    mahalanobis = t(t(x_mat)-mu_d) %*% solve(matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2)) %*% (t(x_mat)-mu_d) |> 
      diag() |> 
      sqrt(), # マハラノビス距離
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12_vals, ", ", sigma_12_vals, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  tidyr::pivot_longer(
    cols = c(euclidean, mahalanobis), 
    names_to = "type", 
    values_to = "distance"
  ) # 距離の列をまとめる
anime_dist_df
```

　「分散(1軸)の影響」と同様に処理します。\

　「分散(1軸)の影響」のコードで作図できます。フレーム数は`sigma_12_vals`の要素数です。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# ユークリッド距離とマハラノビス距離のアニメーションを作図
anime_dist_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.5) + # 2次元ガウス分布
  geom_contour(data = anime_dist_df, mapping = aes(x = x_1, y = x_2, z = distance, color = type), 
               breaks = dist_vals, size = 1) + # 距離
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  scale_color_manual(breaks = c("euclidean", "mahalanobis"), values = c("pink", "skyblue"), name = "distance") + # 線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

```{r}
# gif画像を作成
gganimate::animate(anime_dist_graph, nframes = length(sigma_12_vals), fps = 10, width = 800, height = 800)
```

　$\sigma_{1,2}$の値に応じて、マハラノビス距離の楕円の向きが変化しています。\
\

　この記事では、分散共分散行列とユークリッド距離・マハラノビス距離の関係を確認しました。次は、固有値・固有ベクトルとの関係を確認します。\
\


# 分散共分散行列と固有値・固有ベクトルの関係の計算

　分散共分散行列(Variance–Covariance Matrix)と固有値(Eigenvalue)・固有ベクトル(Eigenvector)の関係を計算して確認します。計算式については「分散共分散行列と固有値・固有ベクトルの関係の導出」を参照してください。\
\

　この記事では、`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。  
\


## 分散共分散行列の設定

　まずは、分散共分散行列を設定します。\
\

　分散共分散行列$\boldsymbol{\Sigma}$を作成します。

```{r}
# 次元数を指定
D <- 3

# 分散共分散行列を指定
sigma_dd <- c(
  4, 1.8, -0.1, 
  1.8, 9, 2.4, 
  -0.1, 2.4, 1
) |> # 値を指定
  matrix(nrow = D, ncol = D, byrow = TRUE) # マトリクスに変換
sigma_dd
```

　$D \times D$の正定値行列を指定します。

$$
\boldsymbol{\Sigma}
    = \begin{pmatrix}
          \sigma_1^2 & \sigma_{1,2} & \cdots & \sigma_{1,D} \\
          \sigma_{2,1} & \sigma_2^2 & \cdots & \sigma_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \sigma_{D,1} & \sigma_{D,2} & \cdots & \sigma_D^2
      \end{pmatrix}
$$

　$D$次元ベクトルの変数を$\mathbf{x} = (x_1, x_2, \cdots, x_D)^{\top}$とすると、$\sigma_d$は$x_d$の標準偏差、$\sigma_d^2 = \sigma_{d,d}$は$x_d$の分散、$\sigma_{i,j} = \sigma_{j,i}$は$x_i, x_j$の共分散です。\
　$\sigma_d^2$は正の実数、$\sigma_{i,j}\ (i \neq j)$は実数を満たす必要があります。設定した値に従うっ固有値・固有ベクトルなどを計算します。\
\


## 固有値・固有ベクトルの計算

　次に、設定した分散共分散行列の固有値と固有ベクトルを計算します。\
\

　固有値と固有ベクトルを計算します。

```{r}
# 固有値と固有ベクトルを計算
res_eigen <- eigen(sigma_dd)
res_eigen
```

　$i = 1, 2, \dots, D$の$D$個の固有値$\lambda_i$と固有ベクトル$\mathbf{u}_i = (u_{i,1}, \cdots, u_{i,D})^{\top}$は、`eigen()`で計算します。D個の固有値をまとめたベクトルと、D個の固有ベクトルをそれぞれ列とするマトリクスを格納したリストが出力されます。\

　固有値と固有ベクトルを取り出します。

```{r}
# 固有値を取得
lambda_d <- res_eigen[["values"]]

# 固有ベクトルを取得
u_dd <- res_eigen[["vectors"]] |> 
  t()
lambda_d; u_dd
```

　`"values"`で固有値(をまとめたベクトル)、`"vectors"`で固有ベクトル(をまとめたマトリクス)を取り出せます。数式での成分と合わせるために転置しておきます。\

　$D$個の固有ベクトル$\mathbf{u}_i^{\top}$を行とする(行方向に並べた)$D \times D$の行列を$\mathbf{U}$で表します。

$$
\mathbf{U}
    = \begin{pmatrix}
          \mathbf{u}_1^{\top} \\
          \mathbf{u}_2^{\top} \\
          \vdots \\
          \mathbf{u}_D^{\top}
      \end{pmatrix}
    = \begin{pmatrix}
          u_{1,1} & u_{1,2} & \cdots & u_{1,D} \\
          u_{2,1} & u_{2,2} & \cdots & u_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          u_{D,1} & u_{D,2} & \cdots & u_{D,D}
      \end{pmatrix}
$$

　$\mathbf{U}$の$i$行目が$\mathbf{u}_i$に対応します。\
\


## 固有ベクトルの性質の計算

　固有ベクトルの性質を実際に計算して確認します。\
\

　計算に使う2つの固有ベクトル$\mathbf{u}_i, \mathbf{u}_j$を抽出します。

```{r}
# インデックスを指定
i <- 1
j <- 2

# 固有ベクトルを取得
u_id <- u_dd[i, ]
u_jd <- u_dd[j, ]
```

　インデックスを指定して`u_dd`の要素を抽出します。\

　固有ベクトルの内積を計算します。

```{r}
# 固有ベクトルの内積を計算:式(2.47)
I_ii <- t(u_id) %*% u_id |> 
  as.numeric()
I_ij <- t(u_id) %*% u_jd |> 
  as.numeric()
I_ji <- t(u_jd) %*% u_id |> 
  as.numeric()
I_jj <- t(u_jd) %*% u_jd |> 
  as.numeric()
I_ii; round(I_ij, 5); round(I_ji, 5); I_jj
```

　固有ベクトルの内積は、同じベクトル($i = j$)のとき1、異なるベクトル($i \neq j$)のとき0になります。

$$
\mathbf{u}_i^{\top} \mathbf{u}_j
    = \sum_{d=1}^D
          u_{i,d} u_{j,d}
    = \begin{cases}
          1 &\quad (i = j) \\
          0 &\quad (i \neq j)
      \end{cases}
\tag{2.47}
$$

　ただし、プログラム上の誤差を含みます。\

　固有ベクトルをまとめた行列の積を計算します。

```{r}
# 固有ベクトルをまとめた行列の積を計算
I <- u_dd %*% t(u_dd)
round(I, 5)
```

　$\mathbf{U}$の積は単位行列になります。

$$
\begin{aligned}
\mathbf{U} \mathbf{U}^{\top}
   &= \begin{pmatrix}
          \sum_{d=1}^D u_{1,d} u_{1,d} & 
          \sum_{d=1}^D u_{1,d} u_{2,d} & 
          \cdots & 
          \sum_{d=1}^D u_{1,d} u_{D,d} \\
          \sum_{d=1}^D u_{2,d} u_{1,d} & 
          \sum_{d=1}^D u_{2,d} u_{2,d} & 
          \cdots & 
          \sum_{d=1}^D u_{2,d} u_{D,d} \\
          \vdots & \vdots & \ddots & \vdots \\
          \sum_{d=1}^D u_{D,d} u_{1,d} & 
          \sum_{d=1}^D u_{D,d} u_{2,d} & 
          \cdots & 
          \sum_{d=1}^D u_{D,d} u_{D,d}
      \end{pmatrix}
\\
   &= \begin{pmatrix}
          1 & 0 & \cdots & 0 \\
          0 & 1 & \cdots & 0 \\
          \vdots & \vdots & \ddots & \vdots \\
          0 & 0 & \cdots & 1
      \end{pmatrix}
    = \mathbf{I}
\end{aligned}
$$ 

　掛ける順番を入れ替えて計算します。

```{r}
# 固有ベクトルをまとめた行列の積を計算
I <- t(u_dd) %*% u_dd
round(I, 5)
```

　転置しても(積の順番を入れ替えても)単位行列になります。

$$
\mathbf{U} \mathbf{U}^{\top}
    = \mathbf{I}
$$

　同じ固有ベクトルの積の総和も単位行列になります。

```{r}
# 固有ベクトルの積の総和を計算
I <- matrix(rep(0, times = D*D), nrow = D, ncol = D)
for(i in 1:D) {
  # i番目の固有ベクトルを抽出
  u_id <- u_dd[i, ]
  
  # 固有ベクトルの積を計算
  tmp_uu_dd <- u_id %*% t(u_id)
  
  # D個の和を計算
  I <- I + tmp_uu_dd
}
round(I, 5)
```

　次の式は、$\mathbf{U} \mathbf{U}^{\top}$を展開した式で、この式も単位行列になります。

$$
\sum_{i=1}^D
    \mathbf{u}_i \mathbf{u}_i^{\top}
    = \mathbf{I}
$$ 

　$\mathbf{u}_i \mathbf{u}_i^{\top}$を`tmp_uu_dd`として、`D`回計算して`I`に加えます。\
\

　$\mathbf{U}$は直交行列なので、転置行列と逆行列が一致します。

$$
\mathbf{U}^{\top}
    = \mathbf{U}^{-1}
$$

　$\mathbf{U}$の転置行列を確認します。

```{r}
# 転置行列を計算
u_t_dd <- t(u_dd)
u_t_dd
```

　`t()`で転置できます。\

　$\mathbf{U}$の逆行列を計算します。

```{r}
# 逆行列を計算
u_inv_dd <- solve(u_dd)
u_inv_dd
```

　`solve()`で逆行列を計算できます。\

　両辺の計算結果が一致するのを確認できます。\
\


## 分散共分散行列と固有値・固有ベクトルの関係の計算

　固有ベクトルの性質を確認できたので、分散共分散行列と固有値・固有ベクトルの関係を実際に計算して確認します。\
\

　固有ベクトルの方程式(2.45)が成り立つのを確認します。

$$
\boldsymbol{\Sigma} \mathbf{u}_i
    = \lambda_i \mathbf{u}_i
\tag{2.45}
$$

　分散共分散行列$\boldsymbol{\Sigma}$と固有ベクトル$\mathbf{u}_i$の積を計算します。

```{r}
# 分散共分散行列と固有ベクトルの行列の積:式(2.45)の左辺
sigma_u_d <- sigma_dd %*% u_id |> 
  as.numeric()
sigma_u_d
```

　計算結果は`D`行`1`列のマトリクスになるので、`as.numeric()`でベクトルにします。\

　固有値$\lambda_i$と固有ベクトル$\mathbf{u}_i$の積を計算します。

```{r}
# 固有値と固有ベクトルの積:式(2.45)の右辺
lambda_u_d <- lambda_d[i] * u_id
lambda_u_d
```

　`lambda_i`から`i`番目の要素を取り出して計算します。\

　両辺の計算結果が一致するのを確認できます。\
\

　続いて、$D$個の固有値$\lambda_i$と固有ベクトル$\mathbf{u}_i$を用いて、分散共分散行列$\boldsymbol{\Sigma}$を計算します。

```{r}
# 分散共分散を計算:式(2.48)
res_sigma_dd <- matrix(rep(0, times = D*D), nrow = D, ncol = D)
for(i in 1:D) {
  # i番目の固有値・固有ベクトルを抽出
  lambda_i <- lambda_d[i]
  u_id     <- u_dd[i, ]
  
  # 固有値と2つの固有ベクトルの積を計算
  tmp_sigma_dd <- lambda_i * u_id %*% t(u_id)
  
  # D個の和を計算
  res_sigma_dd <- res_sigma_dd + tmp_sigma_dd
}
res_sigma_dd
```

　次の式で分散共分散行列を計算できます。

$$
\boldsymbol{\Sigma}
    = \sum_{i=1}^D
        \lambda_i
        \mathbf{u}_i \mathbf{u}_i^{\top}
\tag{2.48}
$$

　$\lambda_i \mathbf{u}_i \mathbf{u}_i^{\top}$を`tmp_sigma_dd`として、`D`回計算して`res_sigma_dd`に加えます。\

　$D$個の和をとる計算は、固有値による行列$\boldsymbol{\Lambda}$と固有ベクトルによる行列$\mathbf{U}$を用いても行えます。

```{r}
# 分散共分散を計算:式(2.48')
res_sigma_dd <- t(u_dd) %*% diag(lambda_d) %*% u_dd
res_sigma_dd
```

　$D$個の固有値$\lambda_i$を対角成分とする対角行列

$$
\boldsymbol{\Lambda}
    = \begin{pmatrix}
          \lambda_1 & 0 & \cdots & 0 \\
          0 & \lambda_2 & \cdots & 0 \\
          \vdots & \vdots & \ddots & \vdots \\
          0 & 0 & \cdots & \lambda_D
      \end{pmatrix}
$$

を使って、次の式でも計算できます。($\boldsymbol{\Lambda}$は精度行列ではありません。)

$$
\boldsymbol{\Sigma}
    = \mathbf{U}^{\top} \boldsymbol{\Lambda} \mathbf{U}
$$

　または、ブロードキャストを利用して次のようにも計算できます。

```{r}
# 分散共分散を計算:式(2.48')
res_sigma_dd <- t(lambda_d * u_dd) %*% u_dd
res_sigma_dd
```

　`lambda_d`の各要素をそれぞれ`u_dd`の各行の全ての要素に掛けてから行列の積を計算します。\
\

　分散共分散行列の逆行列$\boldsymbol{\Sigma}^{-1}$を計算します。

```{r}
# 精度行列を計算
sigma_inv_dd <- solve(sigma_dd)
sigma_inv_dd
```

　この値になるのを確認します。\

　固有値と固有ベクトルを用いて、分散共分散行列の逆行列$\boldsymbol{\Sigma}^{-1}$を計算します。

```{r}
# 精度行列を計算:式(2.49)
res_sigma_inv_dd <- matrix(rep(0, times = D*D), nrow = D, ncol = D)
for(i in 1:D) {
  # i番目の固有値・固有ベクトルを抽出
  lambda_i <- lambda_d[i]
  u_id     <- u_dd[i, ]
  
  # 固有値と2つの固有ベクトルの積を計算
  tmp_sigma_inv_dd <- 1/lambda_i * u_id %*% t(u_id)
  
  # D個の和を計算
  res_sigma_inv_dd <- res_sigma_inv_dd + tmp_sigma_inv_dd
}
res_sigma_inv_dd
```

　次の式で分散共分散行列の逆行列を計算できます。

$$
\boldsymbol{\Sigma}^{-1}
    = \sum_{i=1}^D
        \frac{1}{\lambda_i}
        \mathbf{u}_i \mathbf{u}_i^{\top}
\tag{2.49}
$$

　$\frac{1}{\lambda_i} \mathbf{u}_i \mathbf{u}_i^{\top}$を`tmp_sigma_inv_dd`として、`D`回計算して`res_sigma_inv_dd`に加えます。\

　この計算も、$\boldsymbol{\Lambda}$と$\mathbf{U}$を用いて行えます。

```{r}
# 精度行列を計算:式(2.49')
res_sigma_inv_dd <- t(u_dd) %*% diag(1/lambda_d) %*% u_dd
res_sigma_inv_dd
```

　$D$個の固有値の逆数$\frac{1}{\lambda_i}$を対角成分とする対角行列($\boldsymbol{\Lambda}$の逆行列)

$$
\boldsymbol{\Lambda}^{-1}
    = \begin{pmatrix}
          \frac{1}{\lambda_1} & 0 & \cdots & 0 \\
          0 & \frac{1}{\lambda_2} & \cdots & 0 \\
          \vdots & \vdots & \ddots & \vdots \\
          0 & 0 & \cdots & \frac{1}{\lambda_D}
      \end{pmatrix}
$$

を使って、次の式でも計算できます。

$$
\boldsymbol{\Sigma}^{-1}
    = \mathbf{U}^{\top} \boldsymbol{\Lambda}^{-1} \mathbf{U}
$$

　または、ブロードキャストによっても計算できます。

```{r}
# 精度行列を計算:式(2.49')
res_sigma_inv_dd <- t(1/lambda_d * u_dd) %*% u_dd
res_sigma_inv_dd
```

　`1/lambda_d`の各要素をそれぞれ`u_dd`の各行の全ての要素に掛けてから行列の積を計算します。\
\

　この記事では、分散共分散行列と固有値・固有ベクトルの関係を確認しました。次は、固有ベクトルによるガウス分布の回転を確認します。\
\


# 分散共分散行列の固有ベクトルによる分布の回転

　分散共分散行列(Variance–Covariance Matrix)の固有ベクトル(Eigenvector)により回転した多次元ガウス分布(Maltivariate Gaussian Distribution)・多変量正規分布(Maltivariate Normal Distribution)を計算します。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(mvnfast)
library(patchwork)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
library(patchwork)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`は読み込む必要があります。\
　また、`patchwork`パッケージの演算子を使うため、`patchwork`も読み込む必要があります。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
　分布の変化をアニメーション(gif画像)で確認するのに`gganimate`パッケージを利用します。不要であれば省略してください。\
\


## ガウス分布の設定

　まずは、2次元ガウス分布を設定してグラフを作成します。ガウス分布の乱数を使いますが、固有ベクトルによる回転を理解するためのもので、回転自体には不要です。軸の計算やグラフ作成については「2次元ガウス分布の作図」、乱数生成については「多次元ガウス分布の乱数生成」を参照してください。\
\

　ガウス分布のパラメータ$\boldsymbol{\mu}, \boldsymbol{\Sigma}$とサンプルサイズ$N$を設定します。この例では、2次元のグラフで可視化するため、次元数を$D = 2$とします。分布の回転の計算自体は次元数に関わらず行えます。

```{r}
# 次元数を指定
D <- 2

# 平均ベクトルを指定
mu_d <- c(-4, 2)

# 分散共分散行列を指定
sigma_dd <- matrix(c(2, -0.6, -0.6, 1.5), nrow = D, ncol = D)

# データ数(サンプルサイズ)を指定
N <- 10
```

　平均ベクトル$\boldsymbol{\mu} = (\mu_1, \mu_2)^{\top}$、分散共分散行列$\boldsymbol{\Sigma} = (\sigma_1^2, \sigma_{2,1}, \sigma_{1,2}, \sigma_2^2)$とデータ数(サンプルサイズ)$N$を指定します。\
　平均$\mu_d$は実数、分散$\sigma_d^2$は正の実数、共分散$\sigma_{i,j} = \sigma_{j,i}$は実数、また$\boldsymbol{\Sigma}$は正定値行列を満たす必要があります。\

　分散共分散行列の固有値と固有ベクトルを計算します。

```{r}
# 固有値と固有ベクトルを計算
res_eigen <- eigen(sigma_dd)

# 固有値を取得
lambda_d <- res_eigen[["values"]]

# 固有ベクトルを取得
u_dd <- res_eigen[["vectors"]] |> 
  t()
lambda_d; u_dd
```

　$i = 1, 2$の固有値$\lambda_i$と固有ベクトル$\mathbf{u}_i = (u_{i,1}, u_{i,2})^{\top}$を`eigen()`で計算します。2個の固有値をまとめたベクトルと、2個の固有ベクトルをそれぞれ列とするマトリクスを格納したリストが出力されます。\
　`"values"`で固有値(をまとめたベクトル)、`"vectors"`で固有ベクトル(をまとめたマトリクス)を取り出して、数式での成分$\mathbf{U} = (u_{1,1}, u_{2,1}, u_{1,2}, u_{2,2})$と合わせるために転置しておきます。\

　設定したパラメータに応じて、ガウス分布の確率変数の値$\mathbf{x}$を作成して、確率密度を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma_dd[1, 1]) * 3, 
  to = mu_d[1] + sqrt(sigma_dd[1, 1]) * 3, 
  length.out = 100
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma_dd[2, 2]) * 3, 
  to = mu_d[2] + sqrt(sigma_dd[2, 2]) * 3, 
  length.out = 100
)

# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# 多次元ガウス分布を計算
dens_x_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = x_mat, mu = mu_d, sigma = sigma_dd) # 確率密度
)
dens_x_df
```

　$x_1$(x軸)の値を`x_1_vals`、$x_2$(y軸)の値を`x_2_vals`とします。この例では、それぞれ平均を中心に標準偏差の3倍を範囲とします。\
　`x_1_vals`と`x_2_vals`の要素の全ての組み合わせ(格子状の点)を`expand_grid()`で作成します。データフレームが出力されるので、`as.matrix()`でマトリクスに変換して`x_mat`とします。`x_mat`の各行が点$\mathbf{x} = (x_1, x_2)^{\top}$に対応します。\
　多次元ガウス分布の確率密度は、`mvnfast`パッケージの`dmvn()`で計算できます。確率変数の引数`X`に`x_mat`、平均の引数`mu`に`mu_d`、共分散の引数`sigma`に`sigma_dd`を指定します。\

　ガウス分布の乱数を生成します。

```{r}
# 多次元ガウス分布に従う乱数を生成
x_nd <- mvnfast::rmvn(n = N, mu = mu_d, sigma = sigma_dd)

# サンプルを格納
data_x_df <- tibble::tibble(
  n = factor(1:N), # データ番号
  x_1 = x_nd[, 1], # x軸の値
  x_2 = x_nd[, 2] # y軸の値
)
data_x_df
```

　多次元ガウス分布の乱数は、`rmvn()`で生成できます。データ数の引数`n`に`N`、平均の引数`mu`に`mu_d`、分散共分散行列の引数`sigma`に`sigma_dd`を指定します。\
　生成した値`x_nd`の各行を$n = 1, 2, \dots, N$の$N$個のサンプル$\mathbf{x}_n = (x_{n,1}, x_{n,2})^{\top}$とします。\

　ガウス分布の断面図(楕円)の軸を計算します。

```{r}
# 断面図の軸を計算
axis_x_df <- tibble::tibble(
  xstart = mu_d[1] - u_dd[, 1] * sqrt(lambda_d), 
  ystart = mu_d[2] - u_dd[, 2] * sqrt(lambda_d), 
  xend = mu_d[1] + u_dd[, 1] * sqrt(lambda_d), 
  yend = mu_d[2] + u_dd[, 2] * sqrt(lambda_d)
)
axis_x_df
```

　軸番号を$i$、次元を$j$として、始点は$\mu_i - u_{j,i} \sqrt{\lambda_j}$、終点は$\mu_i + u_{j,i} \sqrt{\lambda_j}$で計算できます。$i = 1$がx軸、$i = 2$がy軸に対応します。\

　ガウス分布のグラフを作成します。

```{r, fig.width=8, fig.height=6}
# パラメータラベルを作成:(数式表記用)
param_x_text <- paste0(
  "list(", 
  "mu==group('(', list(", paste0(mu_d, collapse = ", "), "), ')')", 
  ", Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)

# 確率密度の最大値を計算
max_dens <- mvnfast::dmvn(X = mu_d, mu = mu_d, sigma = sigma_dd)

# 2次元ガウス分布のグラフを作成
dens_x_graph <- ggplot() + 
  geom_contour_filled(data = dens_x_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 分布
  geom_contour(data = dens_x_df, mapping = aes(x = x_1, y = x_2, z = density), 
               breaks = max_dens*exp(-0.5), color = "red", size = 1, linetype = "dashed") + # 分布の断面図
  geom_segment(data = axis_x_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸
  geom_point(data = data_x_df, mapping = aes(x = x_1, y = x_2, color = n), 
             alpha = 0.8, size = 5, show.legend = FALSE) + # サンプル
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = param_x_text), 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
dens_x_graph
```

　`geom_contour()`の`breaks`引数に値を指定すると、その値で等高線を引きます。この例では、確率密度の最大値の$\exp(-\frac{1}{2})$倍を指定します。z軸(確率密度)がこの値の面で切断すると断面図(等高線)が軸の先端になります。\
　`geom_segment()`で断面図の軸を描画します。\
\

　この分布の断面図の2つの軸が、それぞれx軸とy軸になるように分布とサンプルを回転します。\
\


## 回転後の分布を計算

　平均値が0になるように並行移動し、分散共分散行列の固有ベクトルを用いて回転したガウス分布を計算します。固有ベクトルについては「分散共分散行列と固有値・固有ベクトルの関係の導出」、固有ベクトルによる回転については「分散共分散行列の固有ベクトルによる分布の回転の導出」を参照してください。\
\

　回転後のガウス分布のパラメータを計算します。

```{r}
# 平均ベクトルを作成
mu_y_d <- rep(0, times = D)

# 分散共分散行列を計算
lambda_dd <- diag(lambda_d)
lambda_dd
```

　全ての次元(軸)の平均が0になるように並行移動するため、平均ベクトルの全ての要素が0になります。\
　分散共分散行列は固有値を対角成分とする対角行列になります。`diag()`にベクトルを渡すと、ベクトルの要素を対角成分とする対角行列を作成します。\

　回転後のガウス分布の確率変数の値$\mathbf{y}$を作成して、確率密度を計算します。

```{r}
# yの値を作成
y_1_vals <- seq(
  from = -sqrt(lambda_dd[1, 1]) * 3, 
  to = sqrt(lambda_dd[1, 1]) * 3, 
  length.out = 100
)
y_2_vals <- seq(
  from = -sqrt(lambda_dd[2, 2]) * 3, 
  to = sqrt(lambda_dd[2, 2]) * 3, 
  length.out = 100
)

# yの点を作成
y_mat <- tidyr::expand_grid(
  y_1 = y_1_vals, 
  y_2 = y_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換

# 多次元ガウス分布を計算
dens_y_df <- tibble::tibble(
  y_1 = y_mat[, 1], # x軸の値
  y_2 = y_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = y_mat, mu = mu_y_d, sigma = lambda_dd) # 確率密度
)
dens_y_df
```

　元の分布のときと同様に、$y_1$(x軸)の値と$y_2$(y軸)の値を作成して、格子状の点`y_mat`を作成します。`y_mat`の各行が点$\mathbf{y} = (y_1, y_2)^{\top}$に対応します。\
　`dmvn()`の`X`引数に`y_mat`、`mu`引数に`mu_y_d`、`sigma`引数に`lambda_dd`を指定して、各点の確率密度を計算します。\

　サンプルを並行移動して回転します。

```{r}
# サンプルを回転
y_nd <- t(t(x_nd) - mu_d) %*% t(u_dd)

# 回転したサンプルを格納
data_y_df <- tibble::tibble(
  n = factor(1:N), 
  y_1 = y_nd[, 1], 
  y_2 = y_nd[, 2]
)
data_y_df
```

　各サンプル$\mathbf{x}_n$から平均値$\boldsymbol{\mu}$を引いて、x軸方向に$-\mu_1$、y軸方向に$-\mu_2$移動します。座標を並行移動した値$(x_1 - \mu_1, x_2 - \mu_2)$に$\mathbf{U}^{\top}$を掛けて回転します。`x_nd`の各行から`mu_d`を引くために、適宜転置して計算します。\

　回転後の分布の軸を計算するために、固有ベクトルを回転します。

```{r}
# 固有ベクトルを回転
u_y_dd <- u_dd %*% t(u_dd)
u_y_dd
```

　$\mathbf{U}$に$\mathbf{U}^{\top}$を掛けて回転します。$\mathbf{U} \mathbf{U}^{\top}$は単位行列$\mathbf{I}$になります。\

　回転した固有ベクトルを使って、回転後の分布の断面図の軸を計算します。

```{r}
# 断面図の軸を計算
axis_y_df <- tibble::tibble(
  xstart = - u_y_dd[, 1] * sqrt(lambda_d), 
  ystart = - u_y_dd[, 2] * sqrt(lambda_d), 
  xend = u_y_dd[, 1] * sqrt(lambda_d), 
  yend = u_y_dd[, 2] * sqrt(lambda_d)
)
axis_y_df
```

　回転後の分布の平均は全ての次元で0なので、始点は$- u_{j,i} \sqrt{\lambda_j}$、終点は$u_{j,i} \sqrt{\lambda_j}$で計算できます。ただし、$u_{j,i}$は回転後の値です。\

　回転後のガウス分布のグラフを作成します。

```{r, fig.width=8, fig.height=6}
# パラメータラベルを作成:(数式表記用)
param_y_text <- paste0(
  "list(", 
  "mu[y]==group('(', list(", paste0(round(mu_y_d, 2), collapse = ", "), "), ')')", 
  ", Lambda[y]==group('(', list(", paste0(round(lambda_dd, 2), collapse = ", "), "), ')')", 
  ")"
)

# 回転後の2次元ガウス分布のグラフを作成
dens_y_graph <- ggplot() + 
  geom_contour_filled(data = dens_y_df, mapping = aes(x = y_1, y = y_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 塗りつぶし等高線
  geom_contour(data = dens_y_df, mapping = aes(x = y_1, y = y_2, z = density), 
               breaks = max_dens*exp(-0.5), color = "red", size = 1, linetype = "dashed") + # 分布の断面図
  geom_segment(data = axis_y_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸
  geom_point(data = data_y_df, mapping = aes(x = y_1, y = y_2, color = n), 
             alpha = 0.8, size = 5, show.legend = FALSE) + 
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = param_y_text), 
       fill = "density", 
       x = expression(y[1]), y = expression(y[2]))
dens_y_graph
```

　元の分布のときと同様にして作図します。\

　回転前の分布と回転後の分布を並べて描画します。

```{r, fig.width=16, fig.height=8}
# グラフを並べて描画
dens_x_graph + dens_y_graph
```

　`patchwork`パッケージの`+`演算子を使うと左右に並べて描画できます。\

　元の分布$\mathcal{N}(\mathbf{y} | \boldsymbol{\mu}, \boldsymbol{\Sigma})$の軸が回転後の分布$\mathcal{N}(\mathbf{y} | \mathbf{0}, \boldsymbol{\Lambda})$の軸と対応しており、回転後の軸がx軸($y_1$軸)とy軸($y_2$軸)と並行なのが分かります。また、元の分布のサンプルも軸に対応するように回転しているのが分かります。\
\


## 固有ベクトルによる分布の回転

　次は、回転後の分布を直接計算するのではなく、元の分布に固有ベクトルの行列を掛けて回転します。\
\

　元の分布の計算・作図用の点$\mathbf{x}$を並行移動して回転します。

```{r}
# xの点を回転
x_to_y_mat <- t(t(x_mat) - mu_d) %*% t(u_dd)
head(x_to_y_mat)
```

　サンプルの回転のときと同様に、$\mathbf{x}$から$\boldsymbol{\mu}$を引き、各次元の平均が0になるように並行移動して、$\mathbf{U}^{\top}$を掛けて回転します。\

　回転後の分布の作図用の点$\mathbf{y}$を作成します。

```{r}
# yの値を作成
y_1_vals <- seq(from = min(x_to_y_mat[, 1]), to = max(x_to_y_mat[, 1]), length.out = 100)
y_2_vals <- seq(from = min(x_to_y_mat[, 2]), to = max(x_to_y_mat[, 2]), length.out = 100)

# yの点を作成
y_mat <- tidyr::expand_grid(
  y_1 = y_1_vals, 
  y_2 = y_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換
head(y_mat)
```

　等高線の作図には、格子点を用意する必要があります。そこで、`x_mat`を回転した`x_to_y_mat`の最小値と最大値を使って、回転後の座標の点$\mathbf{y} = (y_1, y_2)^{\top}$を作成します。\

　回転後の分布の計算用の点を作成します。

```{r}
# yの点を回転
y_to_x_mat = y_mat %*% solve(t(u_dd))
head(y_to_x_mat)
```

　回転前の分布のパラメータで確率密度を計算するため、$\mathbf{y}$に対応する回転前の座標の点を用意する必要があります。そこで、$\mathbf{y}$に$\mathbf{U}^{\top}$の逆行列を掛けて、元の座標の点に回転し(戻し)ます。ちなみに、$\mathbf{U}$は直交行列なので$(\mathbf{U}^{\top})^{-1} = \mathbf{U}$です。\

　回転後の分布を計算します。

```{r}
# 多次元ガウス分布を計算
dens_y_df <- tibble::tibble(
  y_1 = y_mat[, 1], # x軸の値
  y_2 = y_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = y_to_x_mat, mu = rep(0,2), sigma = sigma_dd) # 確率密度
)
dens_y_df
```

　回転後の座標($y_1, y_2$軸座標)の値で作図するために、データフレームに`y_mat`の値を格納します。そして、元の座標($x_1, x_2$軸座標)の値で計算するために、`dmvn()`の`X`引数に`y_to_x_mat`を指定して確率密度を計算します。\

　サンプルを並行移動して回転します。

```{r}
# サンプルを回転
y_nd <- t(t(x_nd) - mu_d) %*% t(u_dd)

# 回転したサンプルを格納
data_y_df <- tibble::tibble(
  n = factor(1:N), 
  y_1 = y_nd[, 1], 
  y_2 = y_nd[, 2]
)
data_y_df
```

　「回転後の分布の計算」のときと同じ処理です。\

　元の分布の軸を並行移動して回転します。

```{r}
# 軸を計算
axis_y_df <- dplyr::bind_cols(
  value_1 = c(axis_x_df[["xstart"]], axis_x_df[["xend"]]) - mu_d[1], 
  value_2 = c(axis_x_df[["ystart"]], axis_x_df[["yend"]]) - mu_d[2]
) |> 
  as.matrix() |> 
  (\(.){. %*% t(u_dd)})() |> 
  as.vector() |> 
  tibble::as_tibble() |> 
  tibble::add_column(
    name = paste0(rep(c("x", "y"), each = 4), rep(c("start", "end"), each = 2, times = 2)), 
    axis = rep(c("y_1", "y_2"), times = 4)
  ) |> 
  tidyr::pivot_wider(
    id_cols = axis, 
    names_from = name, 
    values_from = value
  ) # 軸の視点・終点の列を分割
axis_y_df
```

　2つの軸の始点と終点の8つの値を並行移動して回転します。\
　`axis_x_df`の`xstar, xend`列が$x_1$軸(x軸)の値なので`mu_d[1]`を引き、`ystar, yend`列が$x_2$軸(y軸)の値なので`mu_d[2]`を引きます。\
　並行移動した値を`as.matrix()`で8行2列のマトリクスに変換して、`t(u_dd)`を掛けて回転したり、展開後の列名を作成したり、上手いこと処理します(誰かもっと上手く処理してください…)。\
　求めた値を`pivot_wider()`で列名と対応付けて分割します。\

　「回転後の分布の計算」の作図コードで、回転後の分布のグラフを作成します。

```{r, echo=FALSE, fig.width=8, fig.height=6}
# パラメータラベルを作成:(数式表記用)
param_y_text <- paste0(
  "list(", 
  "lambda==group('(', list(", paste0(round(lambda_d, 2), collapse = ", "), "), ')')", 
  ", U==group('(', list(", paste0(round(u_dd, 2), collapse = ", "), "), ')')", 
  ")"
)

# 固有ベクトルを重ねた2次元ガウス分布のグラフを作成
dens_y_graph <- ggplot() + 
  geom_contour_filled(data = dens_y_df, mapping = aes(x = y_1, y = y_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 塗りつぶし等高線
  geom_contour(data = dens_y_df, mapping = aes(x = y_1, y = y_2, z = density), 
               breaks = max_dens*exp(-0.5), color = "red", size = 1, linetype = "dashed") + # 分布の断面図
  geom_segment(data = axis_y_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸
  geom_point(data = data_y_df, mapping = aes(x = y_1, y = y_2, color = n), 
             alpha = 0.8, size = 5, show.legend = FALSE) + 
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = param_y_text), 
       fill = "density", 
       x = expression(y[1]), y = expression(y[2]))
dens_y_graph
```

\ 

　回転前の分布と回転後の分布を並べて描画します。

```{r, echo=FALSE, fig.width=16, fig.height=8}
# グラフを並べて描画
dens_x_graph + dens_y_graph
```

　(描画範囲は異なりますが、)直接求めた回転後の分布と同じグラフになりました。\
\

　この記事では、分散共分散行列の固有ベクトルによる分布の回転を確認しました。\
\

