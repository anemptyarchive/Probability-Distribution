---
title: "多次元ガウス分布"
author: "@anemptyarchive\\thanks{\\url{https://www.anarchive-beta.com/}}"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: TRUE       # 目次
    toc_depth: 3    # 目次の見出しレベル
    toc_float: TRUE # 目次のスクロール追跡
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  message = FALSE, error = FALSE, warning = FALSE # メッセージを非表示
)
```

----

【編集履歴】

- 2022/08/27：「計算」を追加
- 2022/09/01：「作図」を追加

----


# 多次元ガウス分布の計算

　多次元ガウス分布(Maltivariate Gaussian Distribution)・多変量正規分布(Maltivariate Normal Distribution)の確率密度を計算します。多次元ガウス分布については「分布の定義式」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(mvnfast)
```

　この記事では、`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
\


## 確率密度の計算

　多次元ガウス分布に従う確率密度を計算する方法をいくつか確認します。\
\


### 分散共分散行列を使用

　まずは、分散共分散行列を用いてガウス分布を計算します。\
\


#### パラメータの設定

　ガウス分布の次元数$D$とパラメータ$\boldsymbol{\mu}, \boldsymbol{\Sigma}$、確率変数の実現値$\mathbf{x}$を設定します。

```{r}
# 次元数を指定
D <- 3

# 平均ベクトルを指定
mu_d <- c(10, -6, 1.5)

# 分散共分散行列を指定
sigma_dd <- c(
  4, 1.8, -0.1, 
  1.8, 9, 2.4, 
  -0.1, 2.4, 1
) |> # 値を指定
  matrix(nrow = D, ncol = D, byrow = TRUE) # マトリクスに変換

# 確率変数の値を指定
x_d = c(11.5, -5, 0)
```

　平均ベクトル$\boldsymbol{\mu}$と分散共分散行列$\boldsymbol{\Sigma}$、確率変数の値$\mathbf{x}$を指定します。$\boldsymbol{\mu}, \mathbf{x}$は$D$次元ベクトル、$\boldsymbol{\Sigma}$は$D \times D$の行列です。

$$
\boldsymbol{\mu}
    = \begin{pmatrix}
          \mu_1 \\
          \mu_2 \\
          \vdots \\
          \mu_D
      \end{pmatrix}
,\ 
\boldsymbol{\Sigma}
    = \begin{pmatrix}
          \sigma_1^2 & \sigma_{1,2} & \cdots & \sigma_{1,D} \\
          \sigma_{2,1} & \sigma_2^2 & \cdots & \sigma_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \sigma_{D,1} & \sigma_{D,2} & \cdots & \sigma_D^2
      \end{pmatrix}
,\ 
\mathbf{x}
    = \begin{pmatrix}
          x_1 \\
          x_2 \\
          \vdots \\
          x_D
      \end{pmatrix}
$$

　$\sigma_d^2 = \sigma_{d,d}$は$x_d$の分散、$\sigma_{i,j}$は$x_i$と$x_j$の共分散です。\
　$x_d$は実数をとり、$\mu_d$は実数、$\sigma_d^2$は正の実数、$\sigma_{i,j}\ (i \neq j)$は実数、また$\boldsymbol{\Sigma}$は正定値行列を満たす必要があります。設定した値に従う確率密度を計算します。\
\


#### スクラッチで計算

　定義式から計算します。

```{r}
# 定義式により確率密度を計算
C_N  <- 1 / sqrt((2 * pi)^D * det(sigma_dd))
dens <- C_N * exp(-0.5 * t(x_d - mu_d) %*% solve(sigma_dd) %*% (x_d - mu_d)) |> 
  as.numeric()
dens
```

　ガウス分布は、次の式で定義されます。

$$
\begin{aligned}
C_{\mathcal{N}}
   &= \frac{1}{\sqrt{(2 \pi)^D |\boldsymbol{\Sigma}|}}
\\
\mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})
   &= C_{\mathcal{N}}
      \exp \left\{
          - \frac{1}{2}
            (\mathbf{x} - \boldsymbol{\mu})^{\top}
            \boldsymbol{\Sigma}^{-1}
            (\mathbf{x} - \boldsymbol{\mu})
      \right\}
\end{aligned}
$$

　ここで、$C_{\mathcal{N}}$はガウス分布の正規化係数、$\pi$は円周率、$\mathbf{A}^{\top}$は転置行列、$|\mathbf{A}|$は行列式、$\mathbf{A}^{-1}$は逆行列です。\
　円周率は`pi`、転置は`t()`、行列式は`det()`、逆行列`solve()`、行列の積は`%*%`演算子で計算できます。\

　対数をとった定義式から計算します。

```{r}
# 対数をとった定義式により確率密度を計算
log_C_N  <- -0.5 * (D * log(2 * pi) + log(det(sigma_dd)))
log_dens <- log_C_N - 0.5 * t(x_d - mu_d) %*% solve(sigma_dd) %*% (x_d - mu_d) |> 
  as.numeric()
dens <- exp(log_dens)
dens; log_dens
```

　対数をとった定義式を計算します。

$$
\begin{aligned}
\log C_{\mathcal{N}}
   &= - \frac{1}{2} \Bigl\{
          D \log(2 \pi) + \log |\boldsymbol{\Sigma}|
      \Bigr\}
\\
\log \mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})
   &= \log C_{\mathcal{N}}
      - \frac{1}{2}
        (\mathbf{x} - \boldsymbol{\mu})^{\top}
        \boldsymbol{\Sigma}^{-1}
        (\mathbf{x} - \boldsymbol{\mu})
\end{aligned}
$$

　計算結果の指数をとると確率密度が得られます。

$$
\mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})
    = \exp \Bigr(
          \log \mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})
      \Bigr)
$$

　指数と対数の性質より$\exp(\log x) = x$です。\

　次は、関数を使って確率密度を計算します。\
\


#### ガウス分布の関数による計算

　`mvnfast`パッケージの多次元ガウス分布の確率密度関数`dmvn()`で計算します。

```{r}
# 多次元ガウス分布の関数により確率密度を計算
dens <- mvnfast::dmvn(X = x_d, mu = mu_d, sigma = sigma_dd)
dens
```

　確率変数の引数`X`に`x_d`、平均の引数`mu`に`mu_d`、分散共分散行列の引数`sigma`に`sigma_dd`を指定します。\

　`log = TRUE`を指定すると対数をとった確率密度を返します。

```{r}
# 多次元ガウス分布の対数をとった関数により確率密度を計算
log_dens <- mvnfast::dmvn(X = x_d, mu = mu_d, sigma = sigma_dd, log = TRUE)
dens <- exp(log_dens)
dens; log_dens
```

　計算結果の指数をとると確率密度が得られます。\
\


### 精度行列を使用

　続いて、精度行列を用いてガウス分布を計算します。\
\


#### パラメータの設定

　ガウス分布の次元数$D$とパラメータ$\boldsymbol{\mu}, \boldsymbol{\Lambda}$、確率変数の実現値$\mathbf{x}$を設定します。

```{r}
# 次元数を指定
D <- 3

# 平均ベクトルを指定
mu_d <- c(10, -6, 1.5)

# 精度行列を指定
lambda_dd <- c(
  4, 1.8, -0.1, 
  1.8, 9, 2.4, 
  -0.1, 2.4, 1
) |> # 値を指定
  matrix(nrow = D, ncol = D, byrow = TRUE) # マトリクスに変換

# 確率変数の値を指定
x_d = c(11.5, -5, 0)
```

　分散共分散行列$\boldsymbol{\Sigma}$の代わりに、精度行列$\boldsymbol{\Lambda}$を指定します。\

　あるいは、$\boldsymbol{\Sigma}$を指定して$\boldsymbol{\Lambda}$を計算します。

```{r}
# 精度行列を計算
lambda_dd <- solve(sigma_dd)
lambda_dd
```

　精度行列は分散共分散行列の逆行列$\boldsymbol{\Lambda} = \boldsymbol{\Sigma}^{-1}$です。\
\


#### スクラッチで計算

　定義式から計算します。

```{r}
# 定義式により確率密度を計算
C_N  <- sqrt(det(lambda_dd) / (2 * pi)^D)
dens <- C_N * exp(-0.5 * t(x_d - mu_d) %*% lambda_dd %*% (x_d - mu_d)) |> 
  as.numeric()
dens
```

　ガウス分布は、次の式で定義されます。

$$
\begin{aligned}
C_{\mathcal{N}}
   &= \left\{
          \frac{|\boldsymbol{\Lambda}|}{(2 \pi)^D}
      \right\}^{\frac{1}{2}}
\\
\mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Lambda}^{-1})
   &= C_{\mathcal{N}}
      \exp \left\{
          - \frac{1}{2}
            (\mathbf{x} - \boldsymbol{\mu})^{\top}
            \boldsymbol{\Lambda}
            (\mathbf{x} - \boldsymbol{\mu})
      \right\}
\end{aligned}
$$

　平方根の性質より$\sqrt{x} = x^{\frac{1}{2}}$、$\sqrt{\frac{x}{y}} = \frac{\sqrt{x}}{\sqrt{y}}$です。\

　対数をとった定義式から計算します。

```{r}
# 対数をとった定義式により確率密度を計算
log_C_N  <- -0.5 * (D * log(2 * pi) - log(det(lambda_dd)))
log_dens <- log_C_N - 0.5 * t(x_d - mu_d) %*% lambda_dd %*% (x_d - mu_d) |> 
  as.numeric()
dens <- exp(log_dens)
dens; log_dens
```

　対数をとった定義式を計算します。

$$
\begin{aligned}
\log C_{\mathcal{N}}
   &= - \frac{1}{2} \Bigl\{
          D \log (2 \pi) - \log |\boldsymbol{\Lambda}|
      \Bigr\}
\\
\log \mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Lambda}^{-1})
   &= \log C_{\mathcal{N}}
      - \frac{1}{2}
        (\mathbf{x} - \boldsymbol{\mu})^{\top}
        \boldsymbol{\Lambda}
        (\mathbf{x} - \boldsymbol{\mu})
\end{aligned}
$$

　計算結果の指数をとると確率密度が得られます。\
\


#### ガウス分布の関数による計算

　ガウス分布の確率密度関数`dmvn()`で計算します。

```{r}
# 多次元ガウス分布の関数により確率密度を計算
dens <- mvnfast::dmvn(X = x_d, mu = mu_d, sigma = solve(lambda_dd))
dens

# 多次元ガウス分布の対数をとった関数により確率密度を計算
log_dens <- mvnfast::dmvn(X = x_d, mu = mu_d, sigma = solve(lambda_dd), log = TRUE)
dens <- exp(log_dens)
dens; log_dens
```

　分散共分散行列の引数`sigma`に`lambda_dd`の逆行列を指定します。\
\


## 統計量の計算

　ガウス分布の分散共分散行列に関する統計量の計算については「分散共分散行列と相関行列の計算」を参照してください。\
\

　この記事では、多次元ガウス分布の計算を確認しました。次は、グラフを作成します。\
\


# 2次元ガウス分布の作図

　2次元ガウス分布(Two-dimensional Gaussian Distribution)・二変量正規分布(Bivariate Normal Distribution)のグラフを作成します。ガウス分布については「定義式の確認」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(mvnfast)
library(gganimate)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`は読み込む必要があります。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
　分布の変化をアニメーション(gif画像)で確認するのに`gganimate`パッケージを利用します。不要であれば省略してください。\
\


## 定義式の確認

　まずは、多次元ガウス分布の定義式を確認します。\
\

　ガウス分布は、次の式で定義されます。

$$
\mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})
    = \frac{1}{\sqrt{(2 \pi)^D |\boldsymbol{\Sigma}|}}
      \exp \left\{
          - \frac{1}{2}
            (\mathbf{x} - \boldsymbol{\mu})^{\top}
            \boldsymbol{\Sigma}^{-1}
            (\mathbf{x} - \boldsymbol{\mu})
      \right\}
\tag{1}
$$

　ここで、$\boldsymbol{\mu}$は平均ベクトル、$\boldsymbol{\Sigma}$は分散共分散行列、$\pi$は円周率です。また、$\mathbf{A}^{\top}$は転置行列、$\mathbf{A}^{-1}$は逆行列、$|\mathbf{A}|$は行列式、ネイピア数$e$による指数関数$e^x = \exp(x)$、平方根$\sqrt{a} = a^{\frac{1}{2}}$です。\
　$\mathbf{x}, \boldsymbol{\mu}$は$D$次元ベクトル、$\boldsymbol{\Sigma}$は$D \times D$の行列です。

$$
\mathbf{x}
    = \begin{pmatrix}
          x_1 \\
          x_2 \\
          \vdots \\
          x_D
      \end{pmatrix}
,\ 
\boldsymbol{\mu}
    = \begin{pmatrix}
          \mu_1 \\
          \mu_2 \\
          \vdots \\
          \mu_D
      \end{pmatrix}
,\ 
\boldsymbol{\Sigma}
    = \begin{pmatrix}
          \sigma_1^2 & \sigma_{1,2} & \cdots & \sigma_{1,D} \\
          \sigma_{2,1} & \sigma_2^2 & \cdots & \sigma_{2,D} \\
          \vdots & \vdots & \ddots & \vdots \\
          \sigma_{D,1} & \sigma_{D,2} & \cdots & \sigma_D^2
      \end{pmatrix}
$$

　$\sigma_d$は$x_d$の標準偏差、$\sigma_d^2 = \sigma_{d,d}$は$x_d$の分散、$\sigma_{i,j} = \sigma_{j,i}$は$x_i, x_j$の共分散です。\
　$x_d$は実数をとり、$\mu_d$は実数、$\sigma, \sigma_d^2$は正の実数、$\sigma_{i,j}\ (i \neq j)$は実数、また$\boldsymbol{\Sigma}$は正定値行列を満たす必要があります。\
\


## グラフの作成

　`ggplot2`パッケージを利用して、ガウス分布のグラフを作成します。ガウス分布の確率密度の計算については「分布の計算」を参照してください。\
\

　ガウス分布のパラメータ$\boldsymbol{\mu}, \boldsymbol{\Sigma}$を設定します。この例では、2次元のグラフで描画するため、次元数を$D = 2$とします。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散共分散行列を指定
sigma_dd <- diag(2) # 単位行列
sigma_dd <- c(1, 0.6, 0.6, 4) |> # 値を指定
  matrix(nrow = 2, ncol = 2) # マトリクスに変換
```

　平均ベクトル$\boldsymbol{\mu} = (\mu_1, \mu_2)$、分散共分散行列$\boldsymbol{\Sigma} = (\sigma_1^2, \sigma_{2,1}, \sigma_{1,2}, \sigma_2^2)$を指定します。\
　平均$\mu_d$は実数、分散$\sigma_d^2$は正の実数、共分散$\sigma_{1,2}$は実数、また$\boldsymbol{\Sigma}$は正定値行列を満たす必要があります。\

　設定したパラメータに応じて、ガウス分布の確率変数がとり得る値$\mathbf{x}$の成分$x_1, x_2$の値を作成します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma_dd[1, 1]) * 3, 
  to = mu_d[1] + sqrt(sigma_dd[1, 1]) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma_dd[2, 2]) * 3, 
  to = mu_d[2] + sqrt(sigma_dd[2, 2]) * 3, 
  length.out = 101
)
head(x_1_vals); head(x_2_vals)
```

　$x_1$(x軸)の値を`x_1_vals`、$x_2$(y軸)の値を`x_2_vals`とします。この例では、それぞれ平均を中心に標準偏差の3倍を範囲とします。\

　$\mathbf{x}$を作成します。

```{r}
# xの点を作成
x_mat <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 格子点を作成
  as.matrix() # マトリクスに変換
head(x_mat)
```

　`x_1_vals`と`x_2_vals`の要素の全ての組み合わせ(格子状の点)を`expand_grid()`で作成します。データフレームが出力されるので、`as.matrix()`でマトリクスに変換して`x_mat`とします。`x_mat`の各行が点$\mathbf{x} = (x_1, x_2)$に対応します。\

　$\mathbf{x}$の点ごとの確率密度を計算します。

```{r}
# 多次元ガウス分布を計算
dens_df <- tibble::tibble(
  x_1 = x_mat[, 1], # x軸の値
  x_2 = x_mat[, 2], # y軸の値
  density = mvnfast::dmvn(X = x_mat, mu = mu_d, sigma = sigma_dd) # 確率密度
)
dens_df
```

　多次元ガウス分布の確率密度は、`mvnfast`パッケージの`dmvn()`で計算できます。確率変数の引数`X`に`x_mat`、平均の引数`mu`に`mu_d`、共分散の引数`sigma`に`sigma_dd`を指定します。\

　パラメータの値を数式で表示するための文字列を作成します。

```{r}
# パラメータラベルを作成:(数式表示用)
formula_text <- paste0(
  "list(", 
  "mu==group('(', list(", paste0(mu_d, collapse = ", "), "), ')')", 
  ", Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)
formula_text
```

　ギリシャ文字などの記号を使った数式を表示する場合は、`expression()`の記法を使います。等号は`"=="`、複数の(数式上の)変数を並べるには`"list(変数1, 変数2)"`とします。(プログラム上の)変数の値を使う場合は、`parse()`の`text`引数に指定します。\

　ガウス分布の等高線図を作成します。

```{r, fig.width=8, fig.height=6}
# 2次元ガウス分布のグラフを作成:等高線図
ggplot() + 
  geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  #geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  labs(
    title ="Maltivariate Gaussian Distribution", 
    subtitle = paste0("mu=(", paste0(mu_d, collapse = ', '), "), Sigma=(", paste0(sigma_dd, collapse = ', '), ")"), # (文字列表記用)
    #subtitle = parse(text = formula_text), # (数式表示用)
    color = "density", # (等高線用)
    fill = "density", # (塗りつぶし等高線用)
    x = expression(x[1]), y = expression(x[2])
  )
```

```{r, echo=FALSE, fig.width=8, fig.height=6}
### 資料作成用:(再掲)

# 2次元ガウス分布のグラフを作成:等高線図
ggplot() + 
  #geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  labs(
    title ="Maltivariate Gaussian Distribution", 
    subtitle = paste0("mu=(", paste0(mu_d, collapse = ', '), "), Sigma=(", paste0(sigma_dd, collapse = ', '), ")"), # (文字列表記用)
    #subtitle = parse(text = formula_text), # (数式表示用)
    color = "density", # (等高線用)
    fill = "density", # (塗りつぶし等高線用)
    x = expression(x[1]), y = expression(x[2])
  )
```

　等高線は`geom_contour()`、塗りつぶし等高線は`geom_contour_filled()`で描画できます。z軸の値の引数`z`に`density`を指定して、等高線の色の引数`color`または塗りつぶしの色の引数`fill`に`..level..`を指定すると、確率密度に応じてグラデーションが付けられます。\

　確率密度の変化を細かく見るには、ヒートマップで可視化します。

```{r, fig.width=8, fig.height=6}
# 2次元ガウス分布のグラフを作成:ヒートマップ
ggplot() + 
  geom_tile(data = dens_df, mapping = aes(x = x_1, y = x_2, fill = density, color = density), alpha = 0.8) + # ヒートマップ
  scale_color_viridis_c(option = "D") + # タイルの色
  scale_fill_viridis_c(option = "D") + # 枠線の色
  #scale_fill_gradientn(colors = c("blue", "green", "yellow", "red")) + # タイルの色
  #scale_color_gradientn(colors = c("blue", "green", "yellow", "red")) + # 枠線の色
  labs(
    title ="Maltivariate Gaussian Distribution", 
    #subtitle = paste0("mu=(", paste0(mu_d, collapse = ', '), "), Sigma=(", paste0(sigma_dd, collapse = ', '), ")"), # (文字列表記用)
    subtitle = parse(text = formula_text), # (数式表記用)
    fill = "density", color = "density", 
    x = expression(x[1]), y = expression(x[2])
  )
```

```{r, echo=FALSE, fig.width=8, fig.height=6}
### 資料作成用:(再掲)

# 2次元ガウス分布のグラフを作成:ヒートマップ
ggplot() + 
  geom_tile(data = dens_df, mapping = aes(x = x_1, y = x_2, fill = density, color = density), alpha = 0.8) + # ヒートマップ
  #scale_color_viridis_c(option = "D") + # タイルの色
  #scale_fill_viridis_c(option = "D") + # 枠線の色
  scale_fill_gradientn(colors = c("blue", "green", "yellow", "red")) + # タイルの色
  scale_color_gradientn(colors = c("blue", "green", "yellow", "red")) + # 枠線の色
  labs(
    title ="Maltivariate Gaussian Distribution", 
    #subtitle = paste0("mu=(", paste0(mu_d, collapse = ', '), "), Sigma=(", paste0(sigma_dd, collapse = ', '), ")"), # (文字列表記用)
    subtitle = parse(text = formula_text), # (数式表記用)
    fill = "density", color = "density", 
    x = expression(x[1]), y = expression(x[2])
  )
```

　ヒートマップは`geom_tile()`で描画できます。\
　グラデーションは`scale_***_viridis_c()`や`scale_***_gradientn()`で設定できます。\

　ガウス分布のグラフを描画できました。以降は、ここまでの作図処理を用いて、パラメータの影響を確認していきます。\
\


## 軸の可視化

　分散共分散行列の固有値と固有ベクトルを用いて、ガウス分布の断面図の軸を作図します。詳しくは「分散共分散行列と固有値・固有ベクトルの関係」を参照してください。\
\

　分散共分散行列の固有値と固有ベクトルを計算します。

```{r}
# 固有値と固有ベクトルを計算
res_eigen <- eigen(sigma_dd)

# 固有値を取得
lambda_d <- res_eigen[["values"]]

# 固有ベクトルを取得
u_dd <- res_eigen[["vectors"]] |> 
  t()
lambda_d; u_dd
```

　固有値$\lambda_1, \lambda_2$と固有ベクトル$\mathbf{u}_1 = (u_{1,1}, u_{1,2}), \mathbf{u}_2 = (u_{2,1}, u_{2,2})$を`eigen()`で計算します。リストが出力されるので、`"values"`で固有値(をまとめたベクトル)、`"vectors"`で固有ベクトル(をまとめたマトリクス)を取り出します。数式での成分と合わせるために転置しておきます。\

　軸の前に、固有ベクトルをグラフで確認するために、固有ベクトルをデータフレームに格納します。

```{r}
# 固有ベクトル
eigen_df <- tibble::tibble(
  xstart = 0, 
  ystart = 0, 
  xend = u_dd[, 1], 
  yend = u_dd[, 2]
)
eigen_df
```

　作図時の引数に対応するように列を作成します。\

　固有ベクトルのグラフを作成します。

```{r, fig.width=6, fig.height=6}
# 固有ベクトル(軸の方向)のグラフを作成
ggplot() + 
  geom_segment(data = eigen_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               size = 1, arrow = arrow()) + # 軸の方向
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title = "Eigenvector", 
       subtitle = parse(text = paste0("U==(list(", paste0(round(u_dd, 2), collapse = ", "), "))")), 
       x = expression(x[1]), y = expression(x[2]))
```

　線分は`geom_segment()`で描画できます。`x`引数に始点のx軸の値、`y`引数に始点のy軸の値、`xend`引数に終点のx軸の値、`yend`引数に終点のy軸の値を指定します。`arrow`引数に`arrow()`を指定すると矢印になります。\
　固有ベクトルが直交ベクトルである(線分が直角に交わる)のを確認するには、アスペクト比を1にします。アスペクト比は`coord_fixed()`で指定できます。\

　同様に、軸の始点と終点を計算して、作図用のデータフレームを作成します。

```{r}
# 断面図の軸を計算
axis_df <- tibble::tibble(
  xstart = mu_d[1] - u_dd[, 1] * sqrt(lambda_d), 
  ystart = mu_d[2] - u_dd[, 2] * sqrt(lambda_d), 
  xend = mu_d[1] + u_dd[, 1] * sqrt(lambda_d), 
  yend = mu_d[2] + u_dd[, 2] * sqrt(lambda_d)
)
axis_df
```

　先ほどは、原点から伸びる長さが1のベクトル(線分)を描画しました。今度は、平均値の点で交差する長さが$\sqrt{\lambda_d}$のベクトル(線分)を描画します。\
　軸番号を$i$、次元を$j$として、始点は$\mu_i - u_{j,i} \sqrt{\lambda_j}$、終点は$\mu_i + u_{j,i} \sqrt{\lambda_j}$で計算できます。\

　固有値と固有ベクトルの値を数式で表示するための文字列を作成します。

```{r}
# 固有値・固有ベクトルラベルを作成:(数式表示用)
eigen_text <- paste0(
  "list(", 
  "lambda==group('(', list(", paste0(round(lambda_d, 2), collapse = ", "), "), ')')", 
  ", U==group('(', list(", paste0(round(u_dd, 2), collapse = ", "), "), ')')", 
  ")"
)
eigen_text
```

　パラメータラベルと同様に指定します。\

　分布の断面の作図用に、確率密度の最大値を計算します。

```{r}
# 確率密度の最大値を計算
max_dens <- mvnfast::dmvn(X = mu_d, mu = mu_d, sigma = sigma_dd)
max_dens
```

　$\mathbf{x} = \boldsymbol{\mu}$のとき学率密度が最大になります。\

　ガウス分布の等高線に軸を重ねたグラフを作成します。

```{r, fig.width=8, fig.height=8}
# 固有ベクトルを重ねた2次元ガウス分布のグラフを作成
ggplot() + 
  geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # ヒートマップ
  #geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
  #                    alpha = 0.8) + # 塗りつぶし等高線
  geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density), breaks = max_dens*exp(-0.5), 
               color = "red", size = 1, linetype = "dashed") + # 分布の断面図
  geom_segment(data = axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸:サイズが固有値の固有ベクトル
  #geom_segment(data = axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸:サイズが固有値の倍の固有ベクトル
  geom_label(mapping = aes(x = mu_d[1], y = mu_d[2]+sqrt(sigma_dd[2, 2])*2, label = eigen_text), 
             parse = TRUE, hjust = 0.5, vjust = 0) + # 固有値・固有ベクトルラベル:(等高線用)
  #geom_label(mapping = aes(x = min(x_1_vals), y = max(x_2_vals), label = eigen_text), 
  #           parse = TRUE, hjust = 0, vjust = 0) + # 固有値・固有ベクトルラベル:(塗りつぶし等高線用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = formula_text), 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

```{r, echo=FALSE, fig.width=8, fig.height=8}
### 資料作成用:(再掲)

# 固有ベクトルを重ねた2次元ガウス分布のグラフを作成
ggplot() + 
  #geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # ヒートマップ
  geom_contour_filled(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 塗りつぶし等高線
  geom_contour(data = dens_df, mapping = aes(x = x_1, y = x_2, z = density), breaks = max_dens*exp(-0.5), 
               color = "red", size = 1, linetype = "dashed") + # 分布の断面図
  #geom_segment(data = axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸:サイズが固有値の固有ベクトル
  geom_segment(data = axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow(length = unit(10, "pt"))) + # 断面図の軸:サイズが固有値の倍の固有ベクトル
  #geom_label(mapping = aes(x = mu_d[1], y = mu_d[2]+sqrt(sigma_dd[2, 2])*2, label = eigen_text), 
  #           parse = TRUE, hjust = 0.5, vjust = 0) + # 固有値・固有ベクトルラベル:(等高線用)
  geom_label(mapping = aes(x = min(x_1_vals), y = max(x_2_vals), label = eigen_text), 
             parse = TRUE, hjust = 0, vjust = 0) + # 固有値・固有ベクトルラベル:(塗りつぶし等高線用)
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = formula_text), 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
```

　`geom_contour()`の`breaks`引数に値を指定すると、その値で等高線を引きます。この例では、確率密度の最大値の$\exp(-\frac{1}{2})$倍を指定します。z軸(確率密度)がこの値の面で切断すると断面図(等高線)が軸の先端になります。\
　`geom_segment()`で断面図の軸を描画します。軸の始点`x, y`引数に平均値`mu_d`を指定すると、平均値から伸びる長さ$\sqrt{\lambda_d}$の固有ベクトル、`axis_df`の`xstart, ystart`列を指定すると断面図全体を通る軸を描画します。\
\


## パラメータと分布の形状の関係

　次は、パラメータの値を少しずつ変化させて、分布の形状の変化をアニメーションで確認します。\
\


### 平均(1軸)の影響

　まずは、x軸方向の平均$\mu_1$の値を変化させ、$\mu_2, \boldsymbol{\Sigma}$を固定します。

```{r}
# x軸の平均として利用する値を指定
mu_1_vals <- seq(from = -2, to = 2, by = 0.04) |> 
  round(digits = 2)

# y軸の平均を指定
mu_2 <- 10

# 分散共分散行列を指定
sigma_dd <- matrix(c(1, 0.6, 0.6, 4), nrow = 2, ncol = 2)

# フレーム数を設定
frame_num <- length(mu_1_vals)
frame_num
```

　値の間隔が一定になるように$\mu_1$の値を`mu_1_vals`として作成します。パラメータごとにフレームを切り替えるので、`mu_1_vals`の要素数がアニメーションのフレーム数になります。\
　また、y軸方向の平均$\mu_2$を`mu_2`として値を指定します。\

　設定したパラメータに応じて、確率変数の値$\mathbf{x}$の成分$x_1, x_2$の値を作成して、パラメータごとに確率密度を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = min(mu_1_vals) - sqrt(sigma_dd[1, 1]) * 2, 
  to = max(mu_1_vals) + sqrt(sigma_dd[1, 1]) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_2 - sqrt(sigma_dd[2, 2]) * 3, 
  to = mu_2 + sqrt(sigma_dd[2, 2]) * 3, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  mu_1 = mu_1_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(mu_1) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = unique(cbind(mu_1, mu_2)), 
      sigma = sigma_dd
    ), # 確率密度
    parameter = paste0("mu=(", mu_1, ", ", mu_2, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")") |> 
      factor(levels = paste0("mu=(", mu_1_vals, ", ", mu_2, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　パラメータ`mu_1_vals`と確率変数`x_1_vals, x_2_vals`の要素の全ての組み合わせを`expand_grid()`を作成します。これにより、パラメータごとに`x_mat`を複製できます。\
　パラメータ列`mu_1`でグループ化することで、`x_mat`ごとに確率密度を計算できます。\
　パラメータごとにフレーム切替用のラベルを作成します。文字列型だと文字列の基準で順序が決まるので、因子型にしてパラメータに応じたレベル(順序)を設定します。\

　等高線図のアニメーション(gif画像)を作成します。

```{r}
# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　`transition_manual()`にフレームの順序を表す列を指定します。この例では、因子型のラベルのレベルの順に描画されます。\
　`animate()`のフレーム数の引数`nframes`にパラメータ数、フレームレートの引数`fps`に1秒当たりのフレーム数を指定します。`fps`引数の値が大きいほどフレームが早く切り替わります。ただし、値が大きいと意図通りに動作しません。\

　同様に、ヒートマップのアニメーションを作成します。

```{r}
# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\mu_1$の値に応じて、x軸方向に移動するのが分かります。\
\


### 平均(2軸)の影響

　続いて、y軸方向の平均$\mu_2$の値を変化させ、$\mu_1, \boldsymbol{\Sigma}$を固定します。

```{r}
# x軸の平均を指定
mu_1 <- 6

# y軸の平均として利用する値を指定
mu_2_vals <- seq(from = -2, to = 2, by = 0.04) |> 
  round(digits = 2)

# 分散共分散行列を指定
sigma_dd <- matrix(c(1, 0.6, 0.6, 4), nrow = 2, ncol = 2)

# フレーム数を設定
frame_num <- length(mu_2_vals)
frame_num
```

　値の間隔が一定になるように$\mu_2$の値を`mu_2_vals`として作成し、x軸方向の平均$\mu_1$を`mu_1`として値を指定します。\

　パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_1 - sqrt(sigma_dd[1, 1]) * 3, 
  to = mu_1 + sqrt(sigma_dd[1, 1]) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = min(mu_2_vals) - sqrt(sigma_dd[2, 2]) * 2, 
  to = max(mu_2_vals) + sqrt(sigma_dd[2, 2]) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  mu_2 = mu_2_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(mu_2) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = unique(cbind(mu_1, mu_2)), 
      sigma = sigma_dd
    ), # 確率密度
    parameter = paste0("mu=(", mu_1, ", ", mu_2, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")") |> 
      factor(levels = paste0("mu=(", mu_1, ", ", mu_2_vals, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「平均(1軸)の影響」の`mu_1, mu_1_vals`と`mu_2, mu_2_vals`を入れ換えるように処理します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\mu_2$の値に応じて、y軸方向に移動するのが分かります。\
\


### 平均(1,2軸)の影響

　$\boldsymbol{\mu}$の値を変化させ、$\boldsymbol{\Sigma}$を固定します。

```{r}
# 平均ベクトルとして利用する値を指定
mu_1_vals <- seq(from = -3, to = 1, by = 0.04) |> 
  round(digits = 2)
mu_2_vals <- seq(from = -4, to = 4, by = 0.08) |> 
  round(digits = 2)

# 分散共分散行列を指定
sigma_dd <- matrix(c(1, 0.6, 0.6, 4), nrow = 2, ncol = 2)

# フレーム数を設定
frame_num <- length(mu_1_vals)
frame_num
```

　`mu_1_vals`と`mu_2_vals`の要素数が同じになるように作成します。\

　パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = min(mu_1_vals) - sqrt(sigma_dd[1, 1]) * 2, 
  to = max(mu_1_vals) + sqrt(sigma_dd[1, 1]) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = min(mu_2_vals) - sqrt(sigma_dd[2, 2]) * 2, 
  to = max(mu_2_vals) + sqrt(sigma_dd[2, 2]) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  idx = seq_along(mu_1_vals), # パラメータ番号
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(idx) |> # 分布の計算用にグループ化
  dplyr::mutate(
    mu_1 = mu_1_vals[idx], 
    mu_2 = mu_2_vals[idx], 
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = unique(cbind(mu_1, mu_2)), 
      sigma = sigma_dd
    ), # 確率密度
    parameter = paste0("mu=(", mu_1, ", ", mu_2, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")") |> 
      factor(levels = paste0("mu=(", mu_1_vals, ", ", mu_2_vals, "), Sigma=(", paste0(sigma_dd, collapse = ", "), ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　パラメータ番号として`1`からパラメータの要素数までの整数を`seq_along()`で作成し、確率変数`x_1_vals, x_2_vals`の要素との全ての組み合わせを`expand_grid()`を作成します。これにより、パラメータごとに`x_mat`を複製できます。\
　パラメータ列`idx`でグループ化し、また`idx`列の値を使って`mu_1_vals, mu_2_vals`から値を取り出して、`x_mat`ごとに確率密度を計算します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\boldsymbol{\mu}$の値に応じて、x軸とy軸の両方向に移動するのが分かります。\
\


### 分散(1軸)の影響

　$\sigma_1^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_{1,2}, \sigma_{2,1}, \sigma_2^2$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# x軸の分散として利用する値を指定
sigma2_1_vals <- seq(from = 0.5, to = 6, by = 0.1) |> 
  round(digits = 2)

# y軸の分散を指定
sigma2_2 <- 4

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_1_vals)
frame_num
```

　値の間隔が一定になるように$\sigma_1^2$の値を`sigma2_1_vals`として作成し、共分散$\sigma_{1,2} = \sigma_{2,1}$を`sigma_12`、y軸方向の分散$\sigma_2^2$を`sigma2_2`として値を指定します。\

　パラメータごとに分布を計算します。

```{r}
# x軸とy軸の値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(max(sigma2_1_vals)) * 2, 
  to = mu_d[1] + sqrt(max(sigma2_1_vals)) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_1 = sigma2_1_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_1) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「平均(1軸)の影響」の`mu_1, mu_1_vals`と`sigma2_1, sigma2_1_vals`を入れ換えるように処理します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\sigma_1^2$の値に応じて、x軸方向に広がり全体の確率密度が小さくなるが分かります。\
\


### 分散(2軸)の影響

　$\sigma_2^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_1^2, \sigma_{1,2}, \sigma_{2,1}$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# x軸の分散を指定
sigma2_1 <- 1

# y軸の分散として利用する値を指定
sigma2_2_vals <- seq(from = 0.5, to = 5, by = 0.1) |> 
  round(digits = 2)

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_2_vals)
frame_num
```

　値の間隔が一定になるように$\sigma_2^2$の値を`sigma2_2_vals`として作成し、x軸方向の分散$\sigma_1^2$を`sigma2_1`、共分散$\sigma_{1,2} = \sigma_{2,1}$を`sigma_12`として値を指定します。\

　パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(max(sigma2_2_vals)) * 2, 
  to = mu_d[2] + sqrt(max(sigma2_2_vals)) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_2 = sigma2_2_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_2) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「平均(1軸)の影響」の`mu_1, mu_1_vals`と`sigma2_2, sigma2_2_vals`を入れ換えるように処理します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\sigma_2^2$の値に応じて、y軸方向に広がり全体の確率密度が小さくなるが分かります。\
\


### 分散(1,2軸)の影響

　$\sigma_2^2, \sigma_2^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_{1,2}, \sigma_{2,1}$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散として利用する値を指定
sigma2_1_vals <- seq(from = 1, to = 4.5, by = 0.1) |> 
  round(digits = 2)
sigma2_2_vals <- seq(from = 1, to = 4.5, by = 0.1) |> 
  round(digits = 2)

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_1_vals)
frame_num
```

　`sigma2_1_vals`と`sigma2_2_vals`の要素数が同じになるように作成します。\

　パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(max(sigma2_1_vals)) * 2, 
  to = mu_d[1] + sqrt(max(sigma2_1_vals)) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(max(sigma2_2_vals)) * 2, 
  to = mu_d[2] + sqrt(max(sigma2_2_vals)) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  idx = seq_along(sigma2_1_vals), # パラメータ番号
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(idx) |> # 分布の計算用にグループ化
  dplyr::mutate(
    sigma2_1 = sigma2_1_vals[idx], 
    sigma2_2 = sigma2_2_vals[idx], 
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「平均(1,2軸)の影響」の`mu_1_vals, mu_2_vals`と`sigma2_1_vals, sigma2_2_vals`を入れ換えるように処理します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\sigma_1^2, \sigma_2^2$の値に応じて、x軸とy軸の両方向に広がり全体の確率密度が小さくなるが分かります。\
\

### 共分散の影響

　$\sigma_{1,2} = \sigma_{1,2}$の値を変化させ、$\boldsymbol{\mu}, \sigma_1^2, \sigma_2^2$を固定します。

```{r}
# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散を指定
sigma2_1 <- 1
sigma2_2 <- 1

# 共分散として利用する値を指定
sigma_12_vals <- seq(from = -0.8, to = 0.8, by = 0.02) |> 
  round(digits = 2)

# フレーム数を設定
frame_num <- length(sigma_12_vals)
frame_num
```

　値の間隔が一定になるように$\sigma_{1,2} = \sigma_{2,1}$の値を`sigma_12_vals`として作成し、分散$\sigma_1^2, \sigma_2^2$を`sigma2_1, sigma2_2`として値を指定します。\

　パラメータごとに分布を計算します。

```{r}
# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma_12 = sigma_12_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma_12) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12_vals, ", ", sigma_12_vals, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_dens_df
```

　「平均(1軸)の影響」の`mu_1, mu_1_vals`と`sigma_12, sigma_12_vals`を入れ換えるように処理します。\

　「平均(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  #geom_contour(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, color = ..level..)) + # 等高線
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), alpha = 0.8) + # 塗りつぶし等高線
  gganimate::transition_manual(parameter) + # フレーム
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 2次元ガウス分布のアニメーションを作図
anime_dens_graph <- ggplot() + 
  geom_tile(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, fill = density), alpha = 0.8) + # ヒートマップ
  gganimate::transition_manual(parameter) + # フレーム
  scale_fill_viridis_c(option = "D") + # 等高線の色
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_dens_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　$\sigma_{1,2}$が0に近いほど全体への散らばり具合が大きくなり、値が小さいほど負の相関が強く、大きいほど正の相関が強くなるのが分かります。\
\


## パラメータと断面図の軸の関係

　前節では、パラメータと分布の関係を確認しました。次は、分布の断面図とその軸を重ねたグラフをアニメーションで確認します。\
\


### 分散(1軸)の影響

　「分布の形状の関係」のコードで、$\sigma_1^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_{1,2}, \sigma_{2,1}, \sigma_2^2$を固定して、`anime_dens_df`を作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 平均ベクトルを指定
mu_d <- c(6, 10)

# x軸の分散として利用する値を指定
sigma2_1_vals <- seq(from = 0.5, to = 6, by = 0.1) |> 
  round(digits = 2)

# y軸の分散を指定
sigma2_2 <- 4

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_1_vals)

# x軸とy軸の値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(max(sigma2_1_vals)) * 2, 
  to = mu_d[1] + sqrt(max(sigma2_1_vals)) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_1 = sigma2_1_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_1) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
```

　分布の断面図を描画する用のデータフレームを作成します。

```{r}
# パラメータごとに楕円を計算
anime_ellipse_df <- anime_dens_df |> 
  dplyr::group_by(sigma2_1) |> # 分布の計算用にグループ化
  dplyr::mutate(
    max_dens = mvnfast::dmvn(
      X = mu_d, 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度の最大値
    density = dplyr::if_else(
      density >= max_dens * exp(-0.5), 
      true = max_dens * exp(-0.5), 
      false = -1
    ) # 断面に変換
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_ellipse_df
```

　`anime_dens_df`の確率密度(`density`列)に対して、パラメータごとに最大値の$\exp(-\frac{1}{2})$倍以上であればこの値に、小さければ`-1`にします(小さい方は他の値でもいいのですが、断面の値に近いとうまく描画できないようです)。\

　断面の軸を計算します。

```{r}
# パラメータごとに楕円の軸を計算
anime_axis_df <- tidyr::expand_grid(
  sigma2_1 = sigma2_1_vals, # パラメータごとに
  name = paste0(rep(c("x", "y"), each = 2, times = 2), rep(c("start", "end"), each = 4)) # 列名
) |> # パラメータごとに受け皿を複製
  dplyr::group_by(sigma2_1) |> # 軸の計算用にグループ化
  dplyr::mutate(
    axis = rep(c("y_1", "y_2"), times = 4), # pivot_wider用の列
    mu = rep(mu_d, each = 2, times = 2), # 平均値
    sign = rep(c(-1, 1), each = 4), # 始点・終点の計算用の符号
    u = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["vectors"]]})() |> 
      t() |> 
      (\(.){rep(as.vector(.), times = 2)})(), # 固有ベクトル
    lambda = matrix(c(unique(sigma2_1), sigma_12, sigma_12, sigma2_2), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["values"]]})() |> 
      (\(.){rep(sqrt(.), times = 4)})(), # 固有値
    value = mu + sign * u * lambda, # 軸の始点・終点を計算
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  dplyr::select(axis, name, value, parameter) |> 
  tidyr::pivot_wider(
    id_cols = c(axis, parameter), 
    names_from = name, 
    values_from = value
  ) # 軸の視点・終点の列を分割
anime_axis_df
```

　パラメータごとに2つの軸の始点と終点の8つの値を計算します。\
　パラメータ`sigma2_1_vals`と8つの値に対応する列名の全ての組み合わせを`expand_grid()`で作成します。これにより、パラメータごとに列名を複製できます。\
　`eigen()`で固有値と固有ベクトルをそれぞれ計算し、上手いことして軸の始点と終点を計算します(誰かもっと上手く処理してください…)。\
　求めた値を`pivot_wider()`で列名と対応付けて分割します。\

　断面図とその軸のアニメーション(gif画像)を作成します。

```{r}
# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  #geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  #geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　分布の形状に応じて、断面図の軸も変化します。\
\


### 分散(2軸)の影響

　「分布の形状の関係」のコードで、$\sigma_2^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_1^2, \sigma_{1,2}, \sigma_{2,1}$を固定して、`anime_dens_df`を作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 平均ベクトルを指定
mu_d <- c(6, 10)

# x軸の分散を指定
sigma2_1 <- 1

# y軸の分散として利用する値を指定
sigma2_2_vals <- seq(from = 0.5, to = 4.5, by = 0.1) |> 
  round(digits = 2)

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_2_vals)

# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(max(sigma2_2_vals)) * 2, 
  to = mu_d[2] + sqrt(max(sigma2_2_vals)) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma2_2 = sigma2_2_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma2_2) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
```

　分布の断面図を描画する用のデータフレームを作成します。

```{r}
# パラメータごとに楕円を計算
anime_ellipse_df <- anime_dens_df |> 
  dplyr::group_by(sigma2_2) |> # 分布の計算用にグループ化
  dplyr::mutate(
    max_dens = mvnfast::dmvn(
      X = mu_d, 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度の最大値
    density = dplyr::if_else(
      density >= max_dens * exp(-0.5), 
      true = max_dens * exp(-0.5), 
      false = -1
    ) # 断面に変換
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_ellipse_df
```

　「分散(1軸)の影響」の`sigma2_1`列を`sigma2_2`列に置き換えるように処理します。\

　断面の軸を計算します。

```{r}
# パラメータごとに楕円の軸を計算
anime_axis_df <- tidyr::expand_grid(
  sigma2_2 = sigma2_2_vals, # パラメータごとに
  name = paste0(rep(c("x", "y"), each = 2, times = 2), rep(c("start", "end"), each = 4)) # 列名
) |> # パラメータごとに受け皿を複製
  dplyr::group_by(sigma2_2) |> # 軸の計算用にグループ化
  dplyr::mutate(
    axis = rep(c("y_1", "y_2"), times = 4), # pivot_wider用の列
    mu = rep(mu_d, each = 2, times = 2), # 平均値
    sign = rep(c(-1, 1), each = 4), # 始点・終点の計算用の符号
    u = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["vectors"]]})() |> 
      t() |> 
      (\(.){rep(as.vector(.), times = 2)})(), # 固有ベクトル
    lambda = matrix(c(sigma2_1, sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["values"]]})() |> 
      (\(.){rep(sqrt(.), times = 4)})(), # 固有値
    value = mu + sign * u * lambda, # 軸の始点・終点を計算
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  dplyr::select(axis, name, value, parameter) |> 
  tidyr::pivot_wider(
    id_cols = c(axis, parameter), 
    names_from = name, 
    values_from = value
  ) # 軸の視点・終点の列を分割
anime_axis_df
```

　「分散(1軸)の影響」の`sigma2_1`列を`sigma2_2`列に置き換えるように処理します。\

　「分散(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  #geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  #geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

　`geom_contour()`の`breaks`引数で任意の値の等高線を引けますが、フレームごとに変更できないので、等高線を引く(断面の)値とそれ以外の値の2値を格納したデータフレームを使います。`bins`引数に等高線の数を指定します。(`1`だとエラーになったので`2`にしています。)\
\


### 分散(1,2軸)の影響

　「分布の形状の関係」のコードで、$\sigma_2^2, \sigma_2^2$の値を変化させ、$\boldsymbol{\mu}, \sigma_{1,2}, \sigma_{2,1}$を固定して、`anime_dens_df`を作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散として利用する値を指定
sigma2_1_vals <- seq(from = 1, to = 4.5, by = 0.1) |> 
  round(digits = 2)
sigma2_2_vals <- seq(from = 1, to = 4.5, by = 0.1) |> 
  round(digits = 2)

# 共分散を指定
sigma_12 <- 0.6

# フレーム数を設定
frame_num <- length(sigma2_1_vals)

# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(max(sigma2_1_vals)) * 2, 
  to = mu_d[1] + sqrt(max(sigma2_1_vals)) * 2, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(max(sigma2_2_vals)) * 2, 
  to = mu_d[2] + sqrt(max(sigma2_2_vals)) * 2, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  idx = seq_along(sigma2_1_vals), # パラメータ番号
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(idx) |> # 分布の計算用にグループ化
  dplyr::mutate(
    sigma2_1 = sigma2_1_vals[idx], 
    sigma2_2 = sigma2_2_vals[idx], 
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
```

　分布の断面図を描画する用のデータフレームを作成します。

```{r}
# パラメータごとに楕円を計算
anime_ellipse_df <- anime_dens_df |> 
  dplyr::group_by(sigma2_1, sigma2_2) |> # 分布の計算用にグループ化
  dplyr::mutate(
    max_dens = mvnfast::dmvn(
      X = mu_d, 
      mu = mu_d, 
      sigma = matrix(c(unique(sigma2_1), sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2)
    ), # 確率密度の最大値
    density = dplyr::if_else(
      density >= max_dens * exp(-0.5), 
      true = max_dens * exp(-0.5), 
      false = -1
    ) # 断面に変換
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_ellipse_df
```

　「分散(1軸)の影響」の`sigma2_1`列に`sigma2_2`列を加えるように処理します。\

　断面の軸を計算します。

```{r}
# パラメータごとに楕円の軸を計算
anime_axis_df <- tidyr::expand_grid(
  idx = seq_along(sigma2_1_vals), # パラメータ番号
  name = paste0(rep(c("x", "y"), each = 2, times = 2), rep(c("start", "end"), each = 4)), # 列名
) |> # パラメータごとに受け皿を複製
  dplyr::group_by(idx) |> # 軸の計算用にグループ化
  dplyr::mutate(
    sigma2_1 = sigma2_1_vals[idx], 
    sigma2_2 = sigma2_2_vals[idx], 
    axis = rep(c("y_1", "y_2"), times = 4), # pivot_wider用の列
    mu = rep(mu_d, each = 2, times = 2), # 平均値
    sign = rep(c(-1, 1), each = 4), # 始点・終点の計算用の符号
    u = matrix(c(unique(sigma2_1), sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["vectors"]]})() |> 
      t() |> 
      (\(.){rep(as.vector(.), times = 2)})(), # 固有ベクトル
    lambda = matrix(c(unique(sigma2_1), sigma_12, sigma_12, unique(sigma2_2)), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["values"]]})() |> 
      (\(.){rep(sqrt(.), times = 4)})(), # 固有値
    value = mu + sign * u * lambda, # 軸の始点・終点を計算
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1_vals, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2_vals, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  dplyr::select(axis, name, value, parameter) |> 
  tidyr::pivot_wider(
    id_cols = c(axis, parameter), 
    names_from = name, 
    values_from = value
  ) # 軸の視点・終点の列を分割
anime_axis_df
```

　パラメータ番号として`1`からパラメータの要素数までの整数を`seq_along()`で作成し、始点と終点用の列名との全ての組み合わせを`expand_grid()`を作成します。\
　`idx`列の値を使って`sigma_1_vals, sigma_2_vals`から値を取り出して、軸の視点と終点を計算します。\

　「分散(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  #geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  #geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

\ 


### 共分散の影響

　「分布の形状の関係」のコードで、$\sigma_{1,2} = \sigma_{1,2}$の値を変化させ、$\boldsymbol{\mu}, \sigma_1^2, \sigma_2^2$を固定して、`anime_dens_df`を作成します。\

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 平均ベクトルを指定
mu_d <- c(6, 10)

# 分散を指定
sigma2_1 <- 1
sigma2_2 <- 1

# 共分散として利用する値を指定
sigma_12_vals <- seq(from = -0.8, to = 0.8, by = 0.02) |> 
  round(digits = 2)

# フレーム数を設定
frame_num <- length(sigma_12_vals)

# xの値を作成
x_1_vals <- seq(
  from = mu_d[1] - sqrt(sigma2_1) * 3, 
  to = mu_d[1] + sqrt(sigma2_1) * 3, 
  length.out = 101
)
x_2_vals <- seq(
  from = mu_d[2] - sqrt(sigma2_2) * 3, 
  to = mu_d[2] + sqrt(sigma2_2) * 3, 
  length.out = 101
)

# パラメータごとに多次元ガウス分布を計算
anime_dens_df <- tidyr::expand_grid(
  sigma_12 = sigma_12_vals, # パラメータ
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # パラメータごとに格子点を複製
  dplyr::group_by(sigma_12) |> # 分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12_vals, ", ", sigma_12_vals, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() # グループ化を解除
```

　分布の断面図を描画する用のデータフレームを作成します。

```{r}
# パラメータごとに楕円を計算
anime_ellipse_df <- anime_dens_df |> 
  dplyr::group_by(sigma_12) |> # 分布の計算用にグループ化
  dplyr::mutate(
    max_dens = mvnfast::dmvn(
      X = mu_d, 
      mu = mu_d, 
      sigma = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2)
    ), # 確率密度の最大値
    density = dplyr::if_else(
      density >= max_dens * exp(-0.5), 
      true = max_dens * exp(-0.5), 
      false = -1
    ) # 断面に変換
  ) |> 
  dplyr::ungroup() # グループ化を解除
anime_ellipse_df
```

　「分散(1軸)の影響」の`sigma2_1`列を`sigma_12`列に置き換えるように処理します。\

　断面の軸を計算します。

```{r}
# パラメータごとに楕円の軸を計算
anime_axis_df <- tidyr::expand_grid(
  sigma_12 = sigma_12_vals, # パラメータごとに
  name = paste0(rep(c("x", "y"), each = 2, times = 2), rep(c("start", "end"), each = 4)) # 列名
) |> # パラメータごとに受け皿を複製
  dplyr::group_by(sigma_12) |> # 軸の計算用にグループ化
  dplyr::mutate(
    axis = rep(c("y_1", "y_2"), times = 4), # pivot_wider用の列
    mu = rep(mu_d, each = 2, times = 2), # 平均値
    sign = rep(c(-1, 1), each = 4), # 始点・終点の計算用の符号
    u = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["vectors"]]})() |> 
      t() |> 
      (\(.){rep(as.vector(.), times = 2)})(), # 固有ベクトル
    lambda = matrix(c(sigma2_1, unique(sigma_12), unique(sigma_12), sigma2_2), nrow = 2, ncol = 2) |> 
      (\(.){eigen(.)[["values"]]})() |> 
      (\(.){rep(sqrt(.), times = 4)})(), # 固有値
    value = mu + sign * u * lambda, # 軸の始点・終点を計算
    parameter = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12, ", ", sigma_12, ", ", sigma2_2, ")") |> 
      factor(levels = paste0("mu=(", mu_d[1], ", ", mu_d[2], "), Sigma=(", sigma2_1, ", ", sigma_12_vals, ", ", sigma_12_vals, ", ", sigma2_2, ")")) # フレーム切替用ラベル
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  dplyr::select(axis, name, value, parameter) |> 
  tidyr::pivot_wider(
    id_cols = c(axis, parameter), 
    names_from = name, 
    values_from = value
  ) # 軸の視点・終点の列を分割
anime_axis_df
```

　「分散(1軸)の影響」の`sigma2_1`列を`sigma_12`列に置き換えるように処理します。\

　「分散(1軸)の影響」のコードで作図できます。

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  #geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

```{r, echo=FALSE}
### 資料作成用:(再掲)

# 楕円の軸のアニメーションを作図
anime_eigen_graph <- ggplot() + 
  geom_contour_filled(data = anime_dens_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # 2次元ガウス分布
  geom_contour(data = anime_ellipse_df, mapping = aes(x = x_1, y = x_2, z = density), 
               bins = 2, color = "red", size = 1, linetype = "dotted") + # 分布の断面
  #geom_segment(data = anime_axis_df, mapping = aes(x = mu_d[1], y = mu_d[2], xend = xend, yend = yend), 
  #             color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の固有ベクトル
  geom_segment(data = anime_axis_df, mapping = aes(x = xstart, y = ystart, xend = xend, yend = yend), 
               color = "blue", size = 1, arrow = arrow()) + # 断面の軸:サイズが固有値の倍の固有ベクトル
  gganimate::transition_manual(parameter) + # フレーム
  coord_fixed(ratio = 1) + # アスペクト比
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = "{current_frame}", 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))

# gif画像を作成
gganimate::animate(anime_eigen_graph, nframes = frame_num, fps = 10, width = 800, height = 600)
```

\ 


# 多次元ガウス分布の乱数生成



# 多次元ガウス分布から確率分布の生成

　多次元ガウス分布(Maltivariate Gaussian Distribution)または多変量正規分布(Maltivariate Normal Distribution)から多次元ガウス分布を生成します。多次元ガウス分布については「分布の定義式」を参照してください。\
\

　利用するパッケージを読み込みます。

```{r, eval=FALSE}
# 利用パッケージ
library(tidyverse)
library(mvnfast)
library(patchwork)
```

```{r, echo=FALSE}
### 資料作成用

# チェック用
library(ggplot2)
library(patchwork)
```

　この記事では、基本的に`パッケージ名::関数名()`の記法を使うので、パッケージを読み込む必要はありません。ただし、作図コードがごちゃごちゃしないようにパッケージ名を省略しているため、`ggplot2`は読み込む必要があります。\
　また、`patchwork`パッケージの演算子を使うため、`patchwork`も読み込む必要があります。\
　`magrittr`パッケージのパイプ演算子`%>%`ではなく、ベースパイプ(ネイティブパイプ)演算子`|>`を使っています。`%>%`に置き換えても処理できます。\
\


## 生成分布の設定

　まずは、パラメータの生成分布としてガウス分布を設定して、ガウス分布の平均ベクトルを生成(サンプリング)します。生成分布を$\mathcal{N}(\boldsymbol{\mu} | \boldsymbol{\mu}_{\mathrm{gen}}, \boldsymbol{\Sigma}_{\mathrm{gen}})$、生成された分布を$\mathcal{N}(\mathbf{x} | \boldsymbol{\mu}, \boldsymbol{\Sigma})$で表すことにします(genはgeneratorのことです)。多次元ガウス分布の作図については「分布の作図」を参照してください。\
\

　ガウス分布(生成分布)のパラメータ$\boldsymbol{\mu}_{\mathrm{gen}}, \boldsymbol{\Sigma}_{\mathrm{gen}}$とサンプルサイズ$N$を設定します。この例では、2次元のグラフで描画するため、次元数を$D = 2$とします。分布の生成自体は次元数に関わらず行えます。

```{r}
# (生成分布の)平均ベクトルを指定
mu_gen_d <- c(4, -2)

# (生成分布の)分散共分散行列を指定
sigma_gen_dd <- matrix(c(1.5, 0.6, 0.6, 1), nrow = 2, ncol = 2, byrow = TRUE)

# 分布の数(サンプルサイズ)を指定
N <- 9
```

　平均ベクトル$\boldsymbol{\mu}_{\mathrm{gen}} = (\mu_1, \mu_2)$、分散共分散行列$\boldsymbol{\Sigma}_{\mathrm{gen}} = (\sigma_1^2, \sigma_{1,2}, \sigma_{2,1}, \sigma_2^2)$とデータ数(パラメータ数)$N$を指定します。\
　$x_d$の平均$\mu_d$は実数、$x_d$の分散$\sigma_d^2$は非負の実数、$x_1, x_2$の共分散$\sigma_{1,2}$は実数、また$\boldsymbol{\Sigma}_{\mathrm{gen}}$は正定値行列を満たす必要があります。\

　ガウス分布に従う乱数を生成します。

```{r}
# 多次元ガウス分布の平均ベクトルμを生成
mu_nd <- mvnfast::rmvn(n = N, mu = mu_gen_d, sigma = sigma_gen_dd)
head(mu_nd)
```

　多次元ガウス分布の乱数は、`mvnfast`パッケージの`rmvn()`で生成できます。データ数の引数`n`に`N`、平均の引数`mu`に`mu_gen_d`、分散共分散行列の引数`sigma`に`sigma_gen_dd`を指定します。\
　生成した値をガウス分布の平均ベクトル$\boldsymbol{\mu}$のN個のサンプル`mu_nd`とします。\

　生成したパラメータ(乱数)をデータフレームに格納します。

```{r}
# パラメータを格納
param_df <- tibble::tibble(
  mu_1 = mu_nd[, 1], 
  mu_2 = mu_nd[, 2], 
) |> # 確率変数(格子点)μを作成
  dplyr::arrange(mu_1, mu_2) |> # 作図時の調整用に並べ替え
  dplyr::mutate(
    parameter = paste0("(", round(mu_1, 2), ", ", round(mu_2, 2), ")") |> 
      factor() # 色分け用ラベル
  )
param_df
```

　`mu_nd`の各列(次元)を列とするデータフレームを作成します。\
　。\

　ガウス分布の期待値$\mathbb{E}[\boldsymbol{\mu}]$を計算します。

```{r}
# パラメータの期待値を計算
E_mu_d <- mu_gen_d
```

　$\boldsymbol{\mu}$の期待値$\mathbb{E}[\boldsymbol{\mu}] = \boldsymbol{\mu}_{\mathrm{gen}}$を`E_mu_d`とします。\
　これは、サンプリングされたパラメータとその分布の基準を示すのに使います。\

　ガウス分布を計算します。

```{r}
# 確率変数μの値を作成
mu_1_vals <- seq(
  from = mu_gen_d[1] - sqrt(sigma_gen_dd[1, 1]) * 3, 
  to = mu_gen_d[1] + sqrt(sigma_gen_dd[1, 1]) * 3, 
  length.out = 101
)
mu_2_vals <- seq(
  from = mu_gen_d[2] - sqrt(sigma_gen_dd[2, 2]) * 3, 
  to = mu_gen_d[2] + sqrt(sigma_gen_dd[2, 2]) * 3, 
  length.out = 101
)

# 多次元ガウス分布を計算
gaussian_generator_df <- tidyr::expand_grid(
  mu_1 = mu_1_vals, 
  mu_2 = mu_2_vals
) |> # 確率変数(格子点)μを作成
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(mu_1, mu_2)), 
      mu = mu_gen_d, 
      sigma = sigma_gen_dd
    ) # 確率密度
  )
gaussian_generator_df
```

　詳しくは「分布の作図」を参照してください。\

　サブタイトルに数式で表示するための文字列を指定します。

```{r}
# パラメータラベルを作成:(数式表記用)
generator_math_text <- paste0(
  "list(", 
  "mu[paste(g,e,n)]==group('(', list(", paste0(mu_gen_d, collapse = ", "), "), ')')", 
  ", Sigma[paste(g,e,n)]==group('(', list(", paste0(sigma_gen_dd, collapse = ", "), "), ')')", 
  ")"
)
generator_math_text
```

　ギリシャ文字などの記号を使った数式を表示する場合は、`expression()`の記法を使います。等号は`"=="`、複数の(数式上の)変数を並べるには`"list(変数1, 変数2)"`とします。(プログラム上の)変数の値を使う場合は、`parse()`の`text`引数に指定します。\
　拘りがなければ不要な処理です。\

　生成分布(ガウス分布)とパラメータのサンプルをプロットします。

```{r, fig.width=8, fig.height=6}
# 2次元ガウス分布を作図
gaussian_generator_graph <- ggplot() + 
  geom_contour_filled(data = gaussian_generator_df, mapping = aes(x = mu_1, y = mu_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # パラメータの生成分布
  geom_point(mapping = aes(x = E_mu_d[1], y = E_mu_d[2]), 
             color = "red", size = 6, shape = 4) + # パラメータの期待値
  geom_point(data = param_df, mapping = aes(x = mu_1, y = mu_2, color = parameter), 
             alpha = 0.8, size = 6) + # パラメータのサンプル
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = generator_math_text), 
       color = expression(mu), fill = "density", 
       x = expression(mu[1]), y = expression(mu[2]))
gaussian_generator_graph
```

　期待値をバツ印で示します。\
\

　以上で、生成分布を設定して、パラメータを生成しました。次は、パラメータのサンプルを用いて、ガウス分布を作図します。\
\


## 分布の作図：多次元ガウス分布

　次に、生成した値をガウス分布の平均ベクトルとして利用します。グラフ作成については「分布の作図」を参照してください。\
\

　パラメータのサンプルごとにガウス分布を計算します。

```{r}
# (生成された分布の)分散共分散行列を指定
sigma_dd <- matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2)
```

　ガウス分布(生成された分布)の確率変数がとり得る値$x$を作成して`x_vals`とします。この例では、作図時に対応関係が分かりやすいように、`mu_vals`の値を使います。\
　`x_vals`と`mu_n`それぞれの要素の全ての組み合わせを`expand_grid()`で作成して、組み合わせごとに確率を計算します。\
　ガウス分布の確率密度を`dnorm()`で計算します。確率変数の引数`x`に`x_vals`の値、平均の引数`mean`に`mu_n`の値、標準偏差の引数`sd`に`sigma`を指定します。\

　生成分布の期待値(生成された分布の平均パラメータの期待値)を用いて、ガウス分布を計算します。

```{r}
# 確率変数xの値を作成
x_1_vals <- mu_1_vals
x_2_vals <- mu_2_vals

# パラメータの期待値による多次元ガウス分布を計算
E_gaussian_df <-  tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals
) |> # 確率変数(格子点)xを作成
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = E_mu_d, 
      sigma = sigma_dd
    ) # 確率密度
  )
E_gaussian_df
```

　`mean`引数に`E_mu_d`を指定します。\

　パラメータのサンプルごとにガウス分布を計算します。

```{r}
# パラメータのサンプルごとに多次元ガウス分布を計算
gaussian_sample_df <- tidyr::expand_grid(
  x_1 = x_1_vals, 
  x_2 = x_2_vals, 
  n = 1:N # データ番号
) |> # 確率変数xをパラメータ数分に複製
  dplyr::mutate(
    mu_1 = mu_nd[n, 1], 
    mu_2 = mu_nd[n, 2], 
  ) |> # パラメータのサンプルを抽出
  dplyr::arrange(mu_1, mu_2, x_1, x_2) |> # 作図時の色付け調整用に並べ替え
  dplyr::group_by(n) |> # 各分布の計算用にグループ化
  dplyr::mutate(
    density = mvnfast::dmvn(
      X = as.matrix(cbind(x_1, x_2)), 
      mu = unique(cbind(mu_1, mu_2)), 
      sigma = sigma_dd
    ) # 確率密度
  ) |> 
  dplyr::ungroup() |> # グループ化を解除
  dplyr::mutate(
    parameter = paste0("(", round(mu_1, 2), ", ", round(mu_2, 2), ")") |> 
      (\(.){factor(., levels = unique(.))})() # 色分け用ラベル
  )
gaussian_sample_df
```

　期待値による分布を破線で示します。\

　パラメータの生成分布(ガウス分布)と生成された分布(ガウス分布)を並べて描画します。

```{r}
# パラメータラベルを作成:(数式表記用)
sample_math_text <- paste0(
  "list(", 
  "Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)
```


　N個のガウス分布を分割して描画します。

```{r, fig.width=8, fig.height=6}
# サンプルによる2次元ガウス分布を作図:分割して表示
gaussian_sample_graph <- ggplot() + 
  geom_contour_filled(data = gaussian_sample_df, mapping = aes(x = x_1, y = x_2, z = density, fill = ..level..), 
                      alpha = 0.8) + # サンプルによる分布
  geom_point(data = param_df, mapping = aes(x = mu_1, y = mu_2, color = parameter), 
             size = 6, shape = 4, show.legend = FALSE) + # サンプルによる分布の期待値
  facet_wrap(. ~ parameter, dir = "v", labeller = label_bquote(mu==.((as.character(parameter))))) + # グラフの分割
  coord_cartesian(xlim = c(min(mu_1_vals), max(mu_1_vals)), ylim = c(min(mu_2_vals), max(mu_2_vals))) + # 軸の表示範囲
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = sample_math_text), 
       fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
gaussian_sample_graph
```

　`facet_wrap()`に列を指定すると、その列の値ごとにグラフを分割して描画できます。\

　パラメータの生成分布(ガウス分布)と生成された分布(ガウス分布)を並べて描画します。

```{r, fig.width=16, fig.height=8}
# グラフを並べて描画
gaussian_generator_graph + gaussian_sample_graph
```

　`patchwork`パッケージの`+`演算子を使うと左右に並べて描画できます。\

　作図用に確率密度(z軸の値)の最大値を計算します。

```{r}
# 確率密度の最大値を計算
max_dens <- mvnfast::dmvn(X = E_mu_d, mu = E_mu_d, sigma = sigma_dd)
max_dens
```

　$\mathbf{x} = \boldsymbol{\mu}$の時の確率密度が最大になります。\



```{r}
# パラメータラベルを作成:(数式表記用)
sample_math_text <- paste0(
  "list(", 
  "E(mu)==group('(', list(", paste0(mu_d, collapse = ", "), "), ')')", 
  ", Sigma==group('(', list(", paste0(sigma_dd, collapse = ", "), "), ')')", 
  ")"
)
sample_math_text
```


　N+1個のガウス分布を作図します。

```{r, fig.width=8, fig.height=6}
# サンプルによる2次元ガウス分布を作図:重ねて表示
gaussian_sample_graph <- ggplot() + 
  geom_contour(data = E_gaussian_df, mapping = aes(x = x_1, y = x_2, z = density), 
               breaks = max_dens*exp(-0.5), color = "red", linetype ="dashed") + # 期待値による分布
  geom_point(mapping = aes(x = E_mu_d[1], y = E_mu_d[2]), 
             color = "red", size = 6, shape = 4) + # 期待値による分布の期待値
  geom_contour(data = gaussian_sample_df, mapping = aes(x = x_1, y = x_2, z = density, color = parameter), 
               breaks = max_dens*exp(-0.5), show.legend = FALSE) + # サンプルによる分布
  geom_point(data = param_df, mapping = aes(x = mu_1, y = mu_2, color = parameter), 
             size = 6, shape = 4, show.legend = FALSE) + # サンプルによる分布の期待値
  coord_cartesian(xlim = c(min(mu_1_vals), max(mu_1_vals)), ylim = c(min(mu_2_vals), max(mu_2_vals))) + # 軸の表示範囲
  labs(title ="Maltivariate Gaussian Distribution", 
       subtitle = parse(text = sample_math_text), 
       color = "density", fill = "density", 
       x = expression(x[1]), y = expression(x[2]))
gaussian_sample_graph
```

　`geom_contour()`の`breaks`引数に、等高線を引くz軸の値を指定します。この例では、確率密度が最大値の$\exp(-\frac{1}{2})$倍の線を描画します。\
　また、期待値による分布を破線で示します。\

　生成分布と生成された分布を並べて描画します。

```{r, fig.width=16, fig.height=8}
# グラフを並べて描画
gaussian_generator_graph + gaussian_sample_graph + 
  patchwork::plot_layout(guides = "collect") # 凡例の位置をまとめる
```

　(定義通りですが)左図におけるパラメータのサンプルの点と、右図における分布のピーク(確率密度が最大となる点・期待値)が対応しているのが分かります。\
\

　この記事では、多次元ガウス分布からの分布生成を確認しました。\
\

